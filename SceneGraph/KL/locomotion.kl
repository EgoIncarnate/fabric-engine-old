
use Math;
use Vec3, Quat, Xfo;
use LinearKeyframe;
use LinearKeyframeTrack;
use LinearKeyframeTrackSet;
use PoseVariables;
use CharacterControllerParams;
use DebugGeometry;
/*
use FabricBULLET;
use BulletWorld;
*/
function activateClip(
  in Integer currFoot,
  in LinearKeyframeTrackSet animationLibrary<>,
  in FootStepTrack footStepTracksLibrary<>[],
  in Integer clipId,
  io TrackSetController trackcontroller,
){
  trackcontroller.activeTrackSet = clipId;
  
  LinearKeyframeTrackSet trackSet = animationLibrary[clipId];
  FootStepTrack footStepTracks[] = footStepTracksLibrary[clipId];
  trackcontroller.stepIds.resize(footStepTracks.size);
  Scalar t;
  if(currFoot < 0){
  //  report("find the first foot lift time:"+trackSet.timeRange+" :"+footStepTracks);
    trackcontroller.time = footStepTracks[0].footSteps[0].liftTime;
    for(Integer j=1; j < footStepTracks.size; j++){
      if(footStepTracks[j].footSteps[0].liftTime > trackcontroller.time){
        trackcontroller.time = footStepTracks[j].footSteps[0].liftTime;
      }
      trackcontroller.stepIds[j] = 0;
    }
  }else{
  //  report("currFoot:"+currFoot);
    // find the first foot lift time for the foot we are on.
    for(Integer j=0; j < footStepTracks[currFoot].footSteps.size; j++){
      if(footStepTracks[currFoot].footSteps[j].liftTime > 0.0){
        trackcontroller.time = footStepTracks[currFoot].footSteps[j].liftTime;
        for(Integer k=0; k < footStepTracks.size; k++){
          trackcontroller.stepIds[k] = j;
        }
        break;
      }
    }
  //  trackcontroller.time = footStepTracks[currFoot].footSteps[0].liftTime;
  //  trackcontroller.stepIds[currFoot] = 0;
  //  for(Integer j=0; j < footStepTracks.size; j++){
  //    if(j==currFoot) continue;
  //    trackcontroller.stepIds[j] = 0;
  //    for(Integer k=0; k < footStepTracks[j].size; k++){
  //      if(footStepTracks[j].footSteps[j].liftTime < trackcontroller.time){
  //        trackcontroller.stepIds[j] = k-1;
  //      }
  //    }
  //  }
    
  }
  trackcontroller.deactivate = false;
//  report("trackcontroller:" + trackcontroller.time);
}

operator evaluateLocomotionPoseVariables(
  io Scalar timestep,
  io Xfo controllerXfo,
  io CharacterControllerParams charactercontrollerparams,
  
  /*
  io BulletWorld  bulletworld,
  */
  io LinearKeyframeTrackSet animationLibrary<>,
  io LocomotionMarker locomotionMarkers<>[],
  io FootStepTrack footStepTracksLibrary<>[],
  
  io KeyframeTrackBindings bindings,
  io TrackSetController trackcontroller,
  
  io Hub hubs[],
  io Limb legs[],
  io COM com,
  io LocomotionFoot locomotionFeet[],
  
  io Boolean plantedFeet[],
  io Vec3 plantLocations[],
  io PoseVariables poseError,
  io PoseVariables poseVariables,
  
  io DebugGeometry debugGeometry
) {
//  report("evaluateLocomotionPoseVariables:");
  if(timestep==0){
    return;
  }
  debugGeometry.reset();
  
    if(trackcontroller.tick == 0){
      activateClip(
        -1,
        animationLibrary,
        footStepTracksLibrary,
        0,
        trackcontroller,
      );
    }
    else if(trackcontroller.deactivate){
      activateClip(
        trackcontroller.pivotFoot,
        animationLibrary,
        footStepTracksLibrary,
        0,
        trackcontroller,
      );
    }

    PoseVariables trackPose = poseVariables;
    LinearKeyframeTrackSet trackSet = animationLibrary[trackcontroller.activeTrackSet];
    FootStepTrack footStepTracks[] = footStepTracksLibrary[trackcontroller.activeTrackSet];
    
    
    Vec2 timeRange = trackSet.timeRange;
    Scalar t = trackcontroller.time;
    
    Vec3 linearVelocity = charactercontrollerparams.displacement.tr / timestep;
    Scalar currSpeed = linearVelocity.length();
    
    Scalar minFrequencyMultiplier = 0.5;
    Scalar clipFrequencyMultiplier = 1.0;
    Scalar strideLengthMultiplier = 0.0;
    Scalar strideLength = 0.0;
    if(trackcontroller.tick > 0){
      if(trackcontroller.comParams[1] > 0.001){
        clipFrequencyMultiplier = (currSpeed / trackcontroller.comParams[1]);
        // When turning, speed up the playback a little to stop the legs getting tangled. 
        clipFrequencyMultiplier += abs(charactercontrollerparams.displacement.ori.getAngle()) * 8.0;
        if(clipFrequencyMultiplier < minFrequencyMultiplier){
          clipFrequencyMultiplier = minFrequencyMultiplier;
        }
        
      }
      strideLength = trackcontroller.comParams[0] * trackcontroller.comParams[1];
      strideLengthMultiplier = currSpeed / trackcontroller.comParams[1] / clipFrequencyMultiplier;
    }
    
  //  report("currSpeed:"+currSpeed + " displacement.angle:"+charactercontrollerparams.displacement.ori.getAngle());
    t += timestep * clipFrequencyMultiplier;
    if(t > timeRange.y){
      t -= (timeRange.y-timeRange.x);
      for(Integer j=0; j < locomotionFeet.size; j++){
        trackcontroller.stepIds[j] = 0;
      }
    }
    trackcontroller.time = t;
    
    trackSet.evaluateKeyframeTracks(
      trackcontroller.time,
      bindings,
      trackPose,
      trackcontroller.currKeys
    );
    trackcontroller.tick++;
    trackcontroller.comParams.resize(com.parameterVarIds.size);
    for(Integer j=0; j < com.parameterVarIds.size; j++){
      trackcontroller.comParams[j] = trackPose.scalarValues[com.parameterVarIds[j]];
    }
    
    
    Xfo hubComs[];
    hubComs.resize(hubs.size);
    if(charactercontrollerparams.trail.size > 0){
      Xfo trailXfo1, trailXfo2;
      Integer id1, id2;
      Xfo lastTrailPoint = charactercontrollerparams.trail[charactercontrollerparams.trailCircularArrayIndex];
      Scalar trailSegmentDist = (controllerXfo.tr - lastTrailPoint.tr).length();
      for(Integer j=0; j < hubs.size; j++){
        Hub hub = hubs[j];
        Xfo hubXfo = trackPose.xfoValues[hub.xfoId];
        Scalar trailDistance = hubXfo.tr.z;
        if(trailDistance < 0.0 && hubs.size > 1){
          
          Scalar trailLookup = ((-trailDistance-trailSegmentDist)/charactercontrollerparams.trailLength) * Scalar(charactercontrollerparams.trail.size);
          Integer trailIndex = Integer(floor(trailLookup));
          Scalar trailInterp = 1.0 - (trailLookup - floor(trailLookup));
          
          id1 = (charactercontrollerparams.trailCircularArrayIndex - trailIndex);
          if(id1 < 0){
            id1 += charactercontrollerparams.trail.size;
          }
          if(trailIndex < 0){
            trailXfo1 = controllerXfo;
          }else{
            trailXfo1 = charactercontrollerparams.trail[id1];
          }
          id2 = (id1 - 1);
          if(id2 < 0){
            id2 += charactercontrollerparams.trail.size;
          }
          trailXfo2 = charactercontrollerparams.trail[id2];
          
          Xfo trailXfo;
          trailXfo.setIdentity();
          trailXfo.tr = trailXfo2.tr.linearInterpolate(trailXfo1.tr, trailInterp);
          trailXfo.ori = trailXfo2.ori.sphericalLinearInterpolate(trailXfo1.ori, trailInterp);
          
          hubComs[j] = trailXfo;
          hubXfo.tr.z = 0.0;
          hubXfo = controllerXfo.inverse() * trailXfo * hubXfo;
          trackPose.xfoValues[hub.xfoId] = hubXfo;
        }
      }
    }
    
    trackcontroller.stepIds.resize(locomotionFeet.size);
    plantedFeet.resize(locomotionFeet.size);
    plantLocations.resize(locomotionFeet.size);
    
    for(Integer j=0; j < locomotionFeet.size; j++){
      LocomotionFoot foot = locomotionFeet[j];
      Limb leg = legs[foot.limbId];
      
      FootStepTrack footStepTrack = footStepTracks[j];
      Integer stepId = trackcontroller.stepIds[j];
      FootStep currStep = footStepTrack.footSteps[stepId];
      Scalar stepRatio = (t - currStep.liftTime) / (currStep.plantTime - currStep.liftTime);
      
      Xfo footXfo, hubComXfo;
      if(leg.hubId < 0){
        hubComXfo = controllerXfo;
      }else{
        //This needs to be rewritten
        hubComXfo = hubComs[leg.hubId];
      }
      footXfo = hubComXfo * trackPose.xfoValues[leg.ikGoalXfoId];
      Scalar stepValue = trackPose.scalarValues[foot.stepTimeVarId];
    //  debugGeometry.drawLine(footXfo.tr, hubComXfo.tr, Color(1.0, 0.0, 1.0, 1.0));
    //  debugGeometry.drawAxis(footXfo, 20.0, Color(1.0, 0.0, 1.0, 1.0));
      
      Vec3 displacementDir;
      if(leg.hubId < 0){
        displacementDir = charactercontrollerparams.displacementDir;
        
      //  displacementDir = (charactercontrollerparams.displacement * leg.ikGoalReferenceXfo).tr - leg.ikGoalReferenceXfo.tr;
      //  debugGeometry.drawLine((charactercontrollerparams.displacement * leg.ikGoalReferenceXfo).tr, leg.ikGoalReferenceXfo.tr, Color(0.0, 0.0, 1.0, 1.0));
      //  displacementDir /= (timestep * trackcontroller.comParams[1]);
      //  displacementDir = leg.ikGoalReferenceXfo.tr charactercontrollerparams.displacementDir;
      }
      else{
        displacementDir = hubComXfo.ori.rotateVector(Vec3(0.0,0.0,1.0));
      }
      
      Xfo footPlantXfo = hubComXfo * leg.ikGoalReferenceXfo;
      Vec3 lift = footPlantXfo.tr - (displacementDir * (strideLength * 0.25 * strideLengthMultiplier));
      footPlantXfo.tr += displacementDir * (strideLength * 0.25 * strideLengthMultiplier);
      footXfo.tr += displacementDir * stepValue * strideLengthMultiplier;
      debugGeometry.drawLine(lift, footPlantXfo.tr, Color(0.0, 1.0, 1.0, 1.0));
      
     //   report(j+" t:"+t+" stepId:"+stepId +" currStep:"+currStep + " stepRatio:"+stepRatio + " planted:"+plantedFeet[j]);
   
        /*
        Vec3 rayStart = footPlantXfo.tr + Vec3(0.0, 10.0, 0.0);
        Vec3 rayDirection = Vec3(0.0, -1.0, 0.0);
        bulletworld.raycast(rayStart,rayDirection);
        if(bulletworld.hit) {
          report("hit");
          debugGeometry.drawLine(rayStart, bulletworld.hitPosition, Color(0.0, 1.0, 1.0, 1.0));
        }
        else{
          debugGeometry.drawLine(rayStart, rayStart + (rayDirection * 10.0), Color(1.0, 1.0, 0.0, 1.0));
        }
        */
      Vec3 footError;
      if(stepRatio > 0.0 && stepRatio < 1.0){
      
        if(plantedFeet[j]){
          // Record the error at lift time.
          footError = plantLocations[j] - footXfo.tr;
          plantLocations[j] = plantLocations[j] - footXfo.tr;
          plantedFeet[j] = false;
          
          if(footStepTrack.footSteps.size > 1){
            if(stepId == footStepTrack.footSteps.size-1){
            //  report("deactivate");
              trackcontroller.deactivate = true;
              trackcontroller.pivotFoot = j;
            }
          }
        }
        else{
          // Interpolate the error across the step.
          if(stepRatio < 0.5){
            Scalar errorDissipation = 1.0 - sin(stepRatio * 2.0 * HALF_PI);
            footError = plantLocations[j] * errorDissipation;
            footError.y = 0.0;
          }
        }
        
        debugGeometry.drawCircle(footPlantXfo, 1.0, Color(0.0, 1.0, 1.0, 1.0));
      }
      else{
        if(!plantedFeet[j]){
          // Record the foot plant pos.
          plantLocations[j] = footXfo.tr;
          plantedFeet[j] = true;
          
          if(footStepTrack.footSteps.size > 1){
            if(trackcontroller.stepIds[j] < footStepTrack.footSteps.size - 1){
              trackcontroller.stepIds[j]++;
            }
          }
        }
        else{
          footError = plantLocations[j] - footXfo.tr;
        }
        debugGeometry.drawCircle(footXfo, 1.0, Color(1.0, 1.0, 0.0, 1.0));
      }
      
      footError.y = 0.0;
      Vec3 upVector = controllerXfo.ori.rotateVector(Vec3(0.0, 1.0, 0.0));
      footXfo.tr -= upVector * footError.dot(upVector);
      footXfo.tr += footError;
        
      Xfo invcontrollerXfo = controllerXfo.inverse();
      trackPose.xfoValues[leg.ikGoalXfoId] = invcontrollerXfo * footXfo;
    //  trackPose.xfoValues[hubs[0].xfoId].tr += invcontrollerXfo.ori.rotateVector(footError) * 0.5;
      
    }
    
  poseVariables = trackPose;
}


