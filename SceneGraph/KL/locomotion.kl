
use Math;
use Vec3, Quat, Xfo;
use LinearKeyframe;
use LinearKeyframeTrack;
use LinearKeyframeTrackSet;
use PoseVariables;
use CharacterControllerParams;
use DebugGeometry;

use FabricBULLET;
use BulletWorld;

function activateClip(
  io LocomotionMarker locomotionMarkers<>[][],
  io TrackSetController trackcontroller,
){
  LocomotionMarker markers[][] = locomotionMarkers[trackcontroller.activeTrackSet];
  LocomotionMarker marker = markers[trackcontroller.pivotFoot][trackcontroller.pivotStepId];
  trackcontroller.time += marker.time;
  trackcontroller.stepIds = marker.stepIds;
  
//  report("activateClip:"+trackcontroller.activeTrackSet+" foot:"+trackcontroller.pivotFoot+ " stepIds:"+marker.stepIds + " t:"+trackcontroller.time);
}

operator evaluateLocomotionPoseVariables(
  io Scalar timestep,
  
  io BulletWorld  bulletworld,
  
  io LinearKeyframeTrackSet animationLibrary<>,
  io LocomotionMarker locomotionMarkers<>[][],
  io FootStepTrack footStepTracksLibrary<>[],
  io KeyframeTrackBindings bindingsLibrary<>,
  
  io Hub hubs[],
  io Limb legs[],
  io COM com,
  io LocomotionFoot locomotionFeet[],
  
  io Xfo controllerXfoSet<>,
  io CharacterControllerParams controllerparamsSet<>,
  
  io TrackSetController trackcontroller,
  io Boolean plantedFeet[],
  io Vec3 plantLocations[],
  io Vec3 hitPositions[],
  io Vec3 hitPositionsPrevStep[],
  
  io PoseVariables poseVariables,
  io PoseVariables prevUpdatePose,
  io PoseVariables poseError,
  io Scalar clipActivationTime,
  in Size index,
  
  io DebugGeometry debugFootMotion,
  io DebugGeometry debugRaycasting
) {
//  report("evaluateLocomotionPoseVariables:"+timestep);
  if(timestep==0.0){
    return;
  }
  debugFootMotion.reset();
  debugRaycasting.reset();
  
  // Constants that mean LLVM optimize our all unused code.
  Boolean displayRaycastingDebugging = true;
  Boolean displayFootPinningDebugging = true;
  Boolean performRaycasting = false;
  
  Xfo controllerXfo = controllerXfoSet[index];
  CharacterControllerParams controllerparams = controllerparamsSet[index];
  
    /////////////////////////////////////////////////
    // Clip Activation
    if(trackcontroller.tick == 0){
      trackcontroller.activeTrackSet = 1;
      Scalar firstFootLift = 9999.0;
      for(Integer k=0; k < locomotionMarkers[trackcontroller.activeTrackSet].size; k++){
        if(locomotionMarkers[trackcontroller.activeTrackSet][k][0].time < firstFootLift){
          trackcontroller.pivotFoot = k;
          firstFootLift = locomotionMarkers[trackcontroller.activeTrackSet][k][0].time;
        }
      }
      activateClip(
        locomotionMarkers,
        trackcontroller,
      );
    }
    else if(trackcontroller.deactivate){
      activateClip(
        locomotionMarkers,
        trackcontroller,
      );
    }

    LinearKeyframeTrackSet trackSet = animationLibrary[trackcontroller.activeTrackSet];
    FootStepTrack footStepTracks[] = footStepTracksLibrary[trackcontroller.activeTrackSet];
    KeyframeTrackBindings bindings = bindingsLibrary[trackcontroller.activeTrackSet];
    
    /////////////////////////////////////////////////
    // Clip Frequency and Stride Length calculation
    Xfo invcontrollerXfo = controllerXfo.inverse();
    Vec2 timeRange = trackSet.timeRange;
    Scalar t = trackcontroller.time;
    
    Vec3 linearVelocity = controllerparams.displacement.tr / timestep;
    Scalar currSpeed = linearVelocity.length();
    Scalar clipSpeedRatio = 1.0;
    Scalar strideLengthModulationFactor = 0.0;
    Scalar clipFrequencyMultiplier = 1.0;
    Scalar strideLengthMultiplier = 1.0;
    Scalar strideLength = 0.0;
    if(trackcontroller.tick > 0){
      // Get the com params from the previous update.
      Scalar stepFrequency = trackcontroller.comParams[0];
      Scalar clipSpeed = trackcontroller.comParams[1];
      strideLength = stepFrequency * clipSpeed;
      
      if(clipSpeed > 0.001){
        clipSpeedRatio = (currSpeed / clipSpeed);

        strideLengthMultiplier = 1.0;//clipSpeedRatio + ((1.0 - clipSpeedRatio) * (1.0 - strideLengthModulationFactor));
        clipFrequencyMultiplier = clipSpeedRatio / strideLengthMultiplier;
        
        // When turning, speed up the playback a little to stop the legs getting tangled. 
      //  clipFrequencyMultiplier += abs(controllerparams.displacement.ori.getAngle()) * 5.0;
      }
    }
    
    /////////////////////////////////////////////////
    // Clip Evaluation
    Scalar timeIncrement = timestep * clipFrequencyMultiplier;
    t += timeIncrement;
    
    trackcontroller.time = t;
    
    poseVariables.evaluateKeyframeTracks(
      trackcontroller.time,
      trackSet,
      bindings,
      trackcontroller.currKeys
    );
    
    /////////////////////////////////////////////////
    // Error dissapation
    if(trackcontroller.tick > 0){
      if(trackcontroller.deactivate){
        poseError = prevUpdatePose.subtract(poseVariables);
        clipActivationTime = t-timestep;
      }
      if(clipActivationTime > 0.0){
        // Blend off the error across the first half a stride. 
        Scalar blendTime = (trackcontroller.comParams[0] * clipFrequencyMultiplier) * 0.5;
        if(t - clipActivationTime < blendTime){
          Scalar weight = 1.0 - ((t - clipActivationTime) / blendTime);
          poseVariables.addWeighted(poseError, weight);
        }
      }
    }
    prevUpdatePose = poseVariables;
    trackcontroller.deactivate = false;
    
    /////////////////////////////////////////////////
    
    trackcontroller.comParams.resize(com.parameterVarIds.size);
    for(Integer j=0; j < com.parameterVarIds.size; j++){
      trackcontroller.comParams[j] = poseVariables.scalarValues[com.parameterVarIds[j]];
    }
    /////////////////////////////////////////////////
  //  report(trackcontroller.tick);
    
    /////////////////////////////////////////////////
    Xfo rot90;
    rot90.setIdentity();
    rot90.ori.setFromAxisAndAngle(Vec3(0.0, 0.0, 1.0), HALF_PI);
    Vec3 upvector = Vec3(0.0, 1.0, 0.0);//controllerXfo.ori.rotateVector(Vec3(0.0, 1.0, 0.0));
    
    Xfo hubComs[];
    for(Integer j=0; j < hubs.size; j++){
      Hub hub = hubs[j];
      Xfo hubXfo = poseVariables.xfoValues[hub.xfoId];
      
      hubXfo.tr = invcontrollerXfo.ori.rotateVector(controllerparams.balanceXfo.ori.rotateVector(controllerXfo.ori.rotateVector(hubXfo.tr))) -
                  invcontrollerXfo.ori.rotateVector(controllerparams.balanceXfo.tr);
      hubXfo.ori =  invcontrollerXfo.ori * controllerparams.balanceXfo.ori * controllerXfo.ori * hubXfo.ori;
      
      if(controllerparams.trail.size > 0){
        hubComs.resize(hubs.size);
        Xfo trailXfo1, trailXfo2;
        Integer id1, id2;
        Xfo lastTrailPoint = controllerparams.trail[controllerparams.trailCircularArrayIndex];
        Scalar trailSegmentDist = (controllerXfo.tr - lastTrailPoint.tr).length();
          
        Scalar trailDistance = hubXfo.tr.z;
      //  report("trailSegmentDist "+j+":"+trailDistance);
        if(trailDistance < 0.0 && hubs.size > 1){
          
          Scalar trailLookup = ((-trailDistance-trailSegmentDist)/controllerparams.trailLength) * Scalar(controllerparams.trail.size);
          Integer trailIndex = Integer(floor(trailLookup));
          Scalar trailInterp = 1.0 - (trailLookup - floor(trailLookup));
          
          id1 = (controllerparams.trailCircularArrayIndex - trailIndex);
          if(id1 < 0){
            id1 += controllerparams.trail.size;
          }
          if(trailIndex < 0){
            trailXfo1 = controllerXfo;
          }else{
            trailXfo1 = controllerparams.trail[id1];
          }
          id2 = (id1 - 1);
          if(id2 < 0){
            id2 += controllerparams.trail.size;
          }
          trailXfo2 = controllerparams.trail[id2];
          
          Xfo trailXfo;
          trailXfo.setIdentity();
          trailXfo.tr = trailXfo2.tr.linearInterpolate(trailXfo1.tr, trailInterp);
          trailXfo.ori = trailXfo2.ori.sphericalLinearInterpolate(trailXfo1.ori, trailInterp);
          
          hubComs[j] = trailXfo;
          hubXfo.tr.z = 0.0;
          hubXfo = invcontrollerXfo * trailXfo * hubXfo;
        }
      }
      
      poseVariables.xfoValues[hub.xfoId] = hubXfo;
    }
    
    /////////////////////////////////////////////////
    trackcontroller.stepIds.resize(locomotionFeet.size);
    plantedFeet.resize(locomotionFeet.size);
    plantLocations.resize(locomotionFeet.size);
    hitPositions.resize(locomotionFeet.size);
    hitPositionsPrevStep.resize(locomotionFeet.size);
    
    Scalar appliedComRayDelta = 0.0;
    Scalar appliedFeetRayDeltas[];
    appliedFeetRayDeltas.resize(locomotionFeet.size);
    Scalar numLegsScalar = 0.0;
    
      
    for(Integer j=0; j < locomotionFeet.size; j++){
      LocomotionFoot foot = locomotionFeet[j];
      Limb leg = legs[foot.limbId];
      
      FootStepTrack footStepTrack = footStepTracks[j];
      Integer stepId = trackcontroller.stepIds[j];
      FootStep currStep = footStepTrack.footSteps[stepId];
      Scalar stepRatio = (t - currStep.liftTime) / (currStep.plantTime - currStep.liftTime);
      
      Xfo footParentSpaceXfo;
      Vec3 displacementDir;
      if(leg.hubId < 0){
        footParentSpaceXfo = controllerXfo;
        displacementDir = controllerparams.displacementDir;
      }
      else{
        footParentSpaceXfo = controllerXfo * poseVariables.xfoValues[hubs[leg.hubId].xfoId];
        displacementDir = hubComs[leg.hubId].ori.rotateVector(Vec3(0.0,0.0,1.0));
      }
      Xfo footXfo = footParentSpaceXfo * poseVariables.xfoValues[leg.ikGoalXfoId];
      Xfo baseFootXfo = footParentSpaceXfo * leg.ikGoalReferenceXfo;
      if(displayFootPinningDebugging){
        debugFootMotion.drawLine(controllerXfo.tr, baseFootXfo.tr, Color(0.0, 0.5, 0.5, 1.0));
        debugFootMotion.drawAxis(footParentSpaceXfo, 3.0, Color(0.0, 0.5, 0.5, 1.0));
      }
      Scalar stepValue = poseVariables.scalarValues[foot.stepTimeVarId];
      
      footXfo.tr -= controllerparams.balanceXfo.tr;
      
      // TODO: this is a bit hackey, and innacurate.
      // One day we should store the plant position
      // relative to the foot positison as an extra track.
      Xfo footPlantXfo = baseFootXfo;
        
      Vec3 liftPos = footPlantXfo.tr - (displacementDir * (strideLength * 0.25 * strideLengthMultiplier));
      footPlantXfo.tr += displacementDir * (strideLength * 0.25 * strideLengthMultiplier);
      footXfo.tr += displacementDir * stepValue * strideLengthMultiplier;
      
      if(displayFootPinningDebugging){
        debugFootMotion.drawLine(liftPos, footPlantXfo.tr, Color(0.0, 0.25, 0.25, 1.0));
      }
      //  report(j+" t:"+t+" stepId:"+stepId +" currStep:"+currStep + " stepRatio:"+stepRatio + " planted:"+plantedFeet[j]);
      
      /////////////////////////////////////////////////
      // Foot Pinning
      if(displayFootPinningDebugging){
        debugFootMotion.drawCircle(footXfo * rot90, 0.1, Color(0.0, 0.5, 0.5, 1.0));
      }
      Vec3 footError;
      if(stepRatio > 0.0 && stepRatio < 1.0){
        if(plantedFeet[j]){
        
          Scalar lift = (hitPositionsPrevStep[j] - footParentSpaceXfo.tr).dot(upvector);
          footXfo.tr += Vec3(0.0, lift, 0.0);
          if(leg.hubId < 0 || leg.hubId == hubs.size-1){
            controllerparams.lift += lift;
            numLegsScalar += 1.0;
          }
        
          // Record the error at lift time.
          footError = invcontrollerXfo.ori.rotateVector(plantLocations[j] - footXfo.tr);
          plantLocations[j] = footError;
          plantedFeet[j] = false;
        }
        else{
        
          // Interpolate the error across the step.
          if(stepRatio < 0.5){
            Scalar errorDissipation = cos(stepRatio * TWO_PI) * 0.5 + 0.5;
            footError = plantLocations[j] * errorDissipation;
            footError.y = 0.0;
          }
          /////////////////////////////////////////////////
          // Raycasting
          if(performRaycasting){
            Vec3 rayStart, rayEnd, refPos, hitPosition;
            refPos = footPlantXfo.tr;
            rayStart = refPos + (upvector * 2.5);
            rayEnd = refPos - (upvector * 2.5);
            
            Boolean filterPassiveObjects = false;  
            BulletContact contacts[];
            bulletworld.raycast(rayStart,rayEnd, filterPassiveObjects,contacts);
            if(contacts.size() > 0) {
              hitPosition = rayStart + (rayEnd - rayStart) * contacts[0].fraction;
              
              if(displayRaycastingDebugging){
                Xfo tmp = footPlantXfo;
                tmp.tr = hitPosition;
                debugRaycasting.drawCircle(tmp * rot90, 0.03, Color(0.0, 1.0, 1.0, 1.0));
                tmp.tr = refPos;
                debugRaycasting.drawCircle(tmp * rot90, 0.05, Color(1.0, 1.0, 1.0, 1.0));
                debugRaycasting.drawLine(rayStart, hitPosition, Color(0.0, 1.0, 1.0, 1.0));
              //  debugRaycasting.drawLine(footParentSpaceXfo.tr, hitPosition, Color(0.0, 1.0, 0.0, 1.0));
              }
              
              Scalar liftIncrement = timeIncrement / (currStep.plantTime - t);
              if(liftIncrement > 1.0){
                liftIncrement = 1.0;
              }
              Scalar lift = ((hitPosition - footParentSpaceXfo.tr).dot(upvector) * liftIncrement);
              footError += Vec3(0.0, lift, 0.0);
              
              hitPositionsPrevStep[j] = hitPosition;
              if(leg.hubId < 0 || leg.hubId == hubs.size-1){
                controllerparams.lift += lift;
                numLegsScalar += 1.0;
              }
            }
            else{
              debugRaycasting.drawLine(rayStart, rayEnd, Color(1.0, 0.0, 0.0, 1.0));
            }
          }
        }
        if(displayFootPinningDebugging){
          debugFootMotion.drawCircle(footPlantXfo * rot90, 0.1, Color(0.0, 0.5, 0.5, 1.0));
        }
      }
      else{
        Scalar lift = (hitPositionsPrevStep[j] - footParentSpaceXfo.tr).dot(upvector);
        footXfo.tr += Vec3(0.0, lift, 0.0);
        if(leg.hubId < 0 || leg.hubId == hubs.size-1){
          controllerparams.lift += lift;
          numLegsScalar += 1.0;
        }
        if(!plantedFeet[j]){
              
          // Record the foot plant pos.
          plantLocations[j] = footXfo.tr;
          plantedFeet[j] = true;
          
        }
        else{
          // Calculate the error each update to hold the foot in place while planted.
          footError = invcontrollerXfo.ori.rotateVector(plantLocations[j] - footXfo.tr);
          footError.y = 0.0;
        }
        
        if(displayFootPinningDebugging){
          debugFootMotion.drawCircle(footXfo * rot90, 0.1, Color(0.5, 0.5, 0.0, 1.0));
          debugFootMotion.drawLine(footXfo.tr, plantLocations[j], Color(0.5, 0.5, 0.0, 1.0));
        }
        
        if(t >= currStep.midPlantTime){
          /////////////////////////////////////////////////
          // Clip Deactivation
          if(animationLibrary.size > 1){
           //   report("currSpeed:"+currSpeed);
            Scalar buffer = 2.0;
            Scalar speedMultipler = 1.0;
            Scalar speedDelta = (currSpeed - (trackcontroller.comParams[1] * speedMultipler));
            if(abs(speedDelta) > buffer){
            //  report("currclipSpeed:"+ (trackcontroller.comParams[1] * speedMultipler) +" speedDelta:"+trackcontroller.activeTrackSet+":"+j+":"+speedDelta);
              for(Integer clipId=0; clipId<locomotionMarkers.size; clipId++){
              // Note: here we block blending from a clip onto its self, but soon we will enable this.
                if(trackcontroller.activeTrackSet == clipId){
                  continue;
                }
                for(Integer l=0; l<locomotionMarkers[clipId][j].size; l++){
                  Scalar speedDelta2 = (currSpeed - (locomotionMarkers[clipId][j][l].params[1] * speedMultipler));
                //  report("clipSpeed:"+ (locomotionMarkers[clipId][j][l].params[1] * speedMultipler) +"speedDelta2 "+clipId+":"+l+":"+speedDelta2);
                  if(abs(speedDelta2) < abs(speedDelta)){
                  //  report("deactivate fromClip:" +trackcontroller.activeTrackSet + " toClip:"+ clipId + " foot:"+j+ " fromStep:"+stepId+ " toStep:"+l);
                    trackcontroller.deactivate = true;
                    trackcontroller.pivotFoot = j;
                    trackcontroller.pivotStepId = l;
                    trackcontroller.activeTrackSet = clipId;
                    trackcontroller.time -= currStep.midPlantTime;
                    break;
                  }
                }
              }
            }
          }
          
          if(!trackcontroller.deactivate && currStep.midPlantTime >= timeRange.y){  
            // Deactivate the current clip if a foot reaches the last step.
          //  report("deactivate - end of clip foot:"+j+ " t:" + trackcontroller.time);
            trackcontroller.deactivate = true;
            trackcontroller.pivotFoot = j;
            trackcontroller.pivotStepId = 0;
            trackcontroller.time -= currStep.midPlantTime;
          }
          
          if(!trackcontroller.deactivate){
            trackcontroller.stepIds[j]++;
          }
        }
      }
      footXfo = invcontrollerXfo * footXfo;
      // Apply the error in COM space. 
      footXfo.tr += footError;
      
      poseVariables.xfoValues[leg.ikGoalXfoId] = footXfo;
      
    }
    if(performRaycasting && numLegsScalar > 0.0){
      controllerparams.lift /= numLegsScalar;
      // Smooth out the com motion by scalaing the lift parameter.
      // Slightly hackey. The applied lift could be calculated better instead of this.
      controllerparams.lift *= 0.5;
      // Note: this is highly illegal. We are copying data back to one of our dependencies.
      // This will be eliminated with nested sub-graphs.
      controllerparamsSet[index] = controllerparams;
    }

    trackcontroller.tick++;
    
}


