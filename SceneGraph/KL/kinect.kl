//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//
use FabricKINECT;
use Vec3;
use Euler;
use Quat;

operator initKinectCamera(
  io KinectCamera camera
){
  Boolean result;
  camera.init(result);
  if(result)
    report('Kinect Camera iniated. Supported Color: '+camera.supportsColor+', Depth: '+camera.supportsDepth+', Skeleton: '+camera.supportsSkeleton);
}

operator tiltKinectCamera(
  io KinectCamera camera,
  io Integer angle
){
  Boolean result;
  camera.tilt(angle,result);
}

operator getKinectCameraAllPixels(
  io KinectCamera camera,
  io Scalar time
){
  if(camera.initiated){
    camera.getColorPixels();
    camera.getDepthPixels();
  }
}

operator getKinectCameraColorPixels(
  io KinectCamera camera,
  io RGBA pixels[],
  io Size width,
  io Size height
){
  if(pixels.size() == 0)
    pixels.resize(width*height);
    
  if(pixels.size() == camera.colorData.size() && camera.initiated && camera.supportsColor){
    pixels = camera.colorData;
  }
}

operator getKinectCameraDepthPixels(
  io KinectCamera camera,
  io Integer pixels[],
  io Size width,
  io Size height
){
  if(pixels.size() == 0)
    pixels.resize(width*height);
    
  if(pixels.size() == camera.depthData.size() && camera.initiated && camera.supportsDepth){
    pixels = camera.depthData;
  }
}

operator getKinectCameraPlayerPixels(
  io KinectCamera camera,
  io Integer pixels[],
  io Size width,
  io Size height
){
  if(pixels.size() == 0)
    pixels.resize(width*height);
    
  if(pixels.size() == camera.depthData.size() && camera.initiated && camera.supportsDepth){
    pixels = camera.playerData;
  }
}

operator getKinectCameraDepthAsColorPixels(
  io KinectCamera camera,
  io RGBA pixels[],
  io Size width,
  io Size height,
  io Integer depthMin,
  io Integer depthMax
){
  if(pixels.size() == 0)
    pixels.resize(width*height);
    
  if(pixels.size() == camera.depthData.size() && camera.initiated && camera.supportsDepth){
    for(Size i=0;i<pixels.size();i++){
      if(camera.depthData[i] == 0){
        pixels[i].r = pixels[i].g = pixels[i].b = pixels[i].a = 0;
      } else {
        Scalar depth = 1.0 - Scalar(camera.depthData[i] - depthMin) / Scalar(depthMax - depthMin);
        if(depth > 1.0) depth = 1.0;
        if(depth < 0.0) depth = 0.0;
        if(camera.playerData[i] == 0)
          pixels[i].r = pixels[i].g = pixels[i].b = Byte(depth * 255.0);
        else if(camera.playerData[i]%6 == 0){
          pixels[i].r = Byte(depth * 255.0);
          pixels[i].g = pixels[i].b = 0;
        }else if(camera.playerData[i]%6 == 1){
          pixels[i].g = Byte(depth * 255.0);
          pixels[i].r = pixels[i].b = 0;
        }else if(camera.playerData[i]%6 == 2){
          pixels[i].b = Byte(depth * 255.0);
          pixels[i].r = pixels[i].g = 0;
        }else if(camera.playerData[i]%6 == 3){
          pixels[i].r = pixels[i].b = Byte(depth * 255.0);
          pixels[i].g = 0;
        }else if(camera.playerData[i]%6 == 4){
          pixels[i].r = pixels[i].g = Byte(depth * 255.0);
          pixels[i].b = 0;
        }else if(camera.playerData[i]%6 == 5){
          pixels[i].g = pixels[i].b = Byte(depth * 255.0);
          pixels[i].r = 0;
        }
          
        pixels[i].a = 255;
      }
    }
  }
}

operator getKinectCameraPoints(
  io KinectCamera camera,
  io Vec3 positions<>,
  io Color colors<>
){
  camera.getPoints(positions,colors);
}
