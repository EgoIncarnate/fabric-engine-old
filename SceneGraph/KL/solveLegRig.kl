//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//


use Xfo;
use Bone;
use BezierKeyframe;
use DebugGeometry;

#include 'FABRIC_ROOT/SceneGraph/KL/solveFishingRod.kl'
#include 'FABRIC_ROOT/SceneGraph/KL/solveNCFIK.kl'

operator solveLegRig(
  io Xfo pose[],
  io Bone bones[],
  io Limb legs[],
  io PoseVariables poseVariables,
  io DebugGeometry debugGeometry
) {
  for( Integer i=0; i<legs.size; i++){
    Limb leg = legs[i];
    
    // Calculate the FK pose of the limb.
    Xfo fkPose[];
    fkPose.resize(leg.boneIds.size());
    for (Integer j = 0; j < leg.boneIds.size(); j++) {
      if(j==0){
        if (bones[leg.boneIds[j]].parent == - 1) {
          fkPose[j] = poseVariables.xfoValues[j];
        }
        else {
          fkPose[j] = pose[bones[leg.boneIds[j]].parent] * poseVariables.xfoValues[leg.xfoIds[j]];
        }
      }
      else {
        fkPose[j] = fkPose[j-1] * poseVariables.xfoValues[leg.xfoIds[j]];
      }
      pose[leg.boneIds[j]] = fkPose[j];
    }
      
    Scalar ikBlend = poseVariables.scalarValues[leg.ikblendId];
    if (ikBlend > 0.0) {
    //  debugGeometry.drawAxis(poseVariables.xfoValues[leg.ikGoalXfoId], 3.0, Color(0.0, 1.0, 1.0, 1.0));
      
      Xfo targetXfo;
      targetXfo = poseVariables.xfoValues[leg.ikGoalXfoId] * leg.ikGoalOffsetXfo;
      
      Scalar maxLineLength = 0.0;
      Integer ikboneIndices[];
      for (Integer j = 0; j < leg.boneIds.size-1; j++) {
        maxLineLength += bones[leg.boneIds[j]].length;
        ikboneIndices.push(leg.boneIds[j]);
      }
    
      Vec2 maxLineLengthSoftening(maxLineLength * 0.03, maxLineLength * 0.03);
      Integer firstBoneId = leg.boneIds[0];
      Integer lastBoneId = leg.boneIds[leg.boneIds.size-1];
      Integer secondLastBoneId = leg.boneIds[leg.boneIds.size-2];
      applyFishingRod(
        targetXfo,
        bones[lastBoneId].length,
        pose[firstBoneId],
        Vec3(-1.0, 0.0, 0.0),
  
        0.0,
        Vec2(0.0, 0.0),
        maxLineLength,
        maxLineLengthSoftening
      );
      targetXfo.tr = targetXfo.transformVector(Vec3(-bones[lastBoneId].length, 0.0, 0.0));
  
      solveNCFIK(pose, bones, ikboneIndices, targetXfo, debugGeometry);
      
      pose[lastBoneId].tr = pose[secondLastBoneId].transformVector(Vec3(bones[secondLastBoneId].length, 0.0, 0.0));
      pose[lastBoneId].ori = targetXfo.ori;
      
      if (ikBlend < 1.0) {
        // Now blend the IK pose with the FK pose.
        for (Integer j = 0; j < leg.boneIds.size(); j++) {
          pose[leg.boneIds[j]].ori = fkPose[j].ori.sphericalLinearInterpolate(pose[leg.boneIds[j]].ori, ikBlend);
          if (j > 0) {
            pose[leg.boneIds[j]].tr = pose[leg.boneIds[j - 1]].transformVector(bones[leg.boneIds[j]].referenceLocalPose.tr);
          }
        }
      }
    }
  }
}



operator invertLegRig(
  io Xfo pose[],
  io Bone bones[],
  io Limb legs[],
  io PoseVariables poseVariables,
  io DebugGeometry debugGeometry
) {
  for( Integer i=0; i<legs.size; i++){
    Limb leg = legs[i];
    
    for (var Integer j = 0; j < leg.boneIds.size; j++) {
      if (bones[leg.boneIds[j]].parent == - 1)
        poseVariables.xfoValues[leg.xfoIds[j]] = pose[leg.boneIds[j]];
      else
        poseVariables.xfoValues[leg.xfoIds[j]] = pose[bones[leg.boneIds[j]].parent].inverse() * pose[leg.boneIds[j]];
    }
    
    Integer ankleIndex = leg.boneIds[2];
    Xfo ankleTipXfo = pose[ankleIndex];
    ankleTipXfo.tr = ankleTipXfo.transformVector(Vec3(bones[ankleIndex].length, 0.0, 0.0));
    poseVariables.xfoValues[leg.ikGoalXfoId] = ankleTipXfo * leg.ikGoalOffsetXfo.inverse();
  }
}