//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use FabricMath;
use Vec2, Vec3, Quat, Xfo;
use Color;
use HashTable;
use DebugGeometry;

operator calcCellIndex(
  io Vec3 position,
  io Vec3 cellcoords,
  io Integer cellindex,
  io HashTable hashtable
) {
  // determine the cell that this particle belongs to.
  cellindex = hashtable.calcCellIndex(hashtable.clampPosition(position), cellcoords);
}

operator populateHashTable(
  io HashTable hashtable,
  io Integer cellIndices<>
) {
  // Reset the hash table, and re-accumulate the ids.
  Size numCells = hashtable.x_count * hashtable.y_count * hashtable.z_count;
  hashtable.cells.resize(numCells);
  for (Index i = 0; i < numCells; ++ i)
    hashtable.cells[i].resize(0);

  for (Integer i = 0; i < cellIndices.size; i++) {
    Integer cellIndex = cellIndices[i];
    hashtable.cells[cellIndex].push(i);
  }
}

operator copyCurrentFrameDataToPrevFrameData(
  io Xfo xfo,
  io Vec3 previousframe_position,
  io HashTable hashtable
) {
  // Clamp the particle within the bounds of the hash grid
  previousframe_position = hashtable.clampPosition(xfo.tr);
}



operator simulateCrowd(
  in Size index,
  io Boolean initialized,
  io Vec3 goal,
  io Integer cellindex,
  io Vec3 cellcoords,

  io Xfo xfo, /* In theory we don't modify this. Only calculate new movement contols.*/
  io Vec3 goalVelocity,
  io Vec3 previousframe_positions<>,
  io Scalar maxLinearVelocity,
  io Scalar maxAngularVelocity,
  io Vec3 linearVelocity,
  

  io Scalar neighborInfluenceRange,
  io Scalar agentRadius,
  io HashTable hashtable,

  io Scalar timestep,

  io Integer neighborIndices[],
  io Scalar neighborDistances[],
  io DebugGeometry debugDraw,
  io Boolean displayDebugging
) {
  if(timestep==0.0){
    return;
  }
  Integer i;
  
  
  
  // We start with our previous frame position, and simulate using the pevious
  // frame data to calculate the new current frame data. This happens in parallal
  // across many particles at once.
  xfo.tr = previousframe_positions[index];
  
  ///////////////////////////////////////////////
  // Broad Phase Interaction Detection
  // This function gathers all the points fomr the current cell, and neighboring cells.
  hashtable.getNeighboringIndices(
    cellindex,
    cellcoords,
    neighborIndices
  );
  
  ///////////////////////////////////////////////
  // Narrow Phase Interaction Detection
  neighborDistances.resize(neighborIndices.size());
  for (i = 0; i < neighborIndices.size; i++) {
    neighborDistances[i] = xfo.tr.distanceTo(previousframe_positions[neighborIndices[i]]);
  }
  
  debugDraw.reset();
  goalVelocity.setNull();
  
  //////////////////////////////////////////////////////
  // Now we do some simulation
  // Goal Seek
  {
    if(displayDebugging){
      debugDraw.drawLine(xfo.tr, goal, Color(0.0, 0.25, 0.0, 1.0));
    }
    Vec3 goalDir = goal - xfo.tr;
    Scalar goalDist = goalDir.length();
    
    
    if (goalDist > neighborInfluenceRange) {
      goalVelocity = goalDir * Vec3(maxLinearVelocity / goalDist, 0.0, maxLinearVelocity / goalDist);
    }
    else if (goalDist > agentRadius) {
      Scalar weight = (goalDist - agentRadius)/(neighborInfluenceRange - agentRadius);
      goalVelocity = goalDir * Vec3((maxLinearVelocity * weight) / goalDist, 0.0, (maxLinearVelocity * weight) / goalDist);
    }
  }
  
  if (neighborIndices.size > 0) {
    
    //////////////////////////////////////////////////////
    // Separation
    {
      Scalar separationWeight = 0.4;
      Scalar separationDistance = neighborInfluenceRange;// * 0.65;
      Scalar neighborInfluenceWeight = 0.0;
      Vec3 separationVector(0.0, 0.0, 0.0);
      Vec3 separationVelocity(0.0, 0.0, 0.0);
      for (i = 0; i < neighborIndices.size; i++) {
        Integer neighborId = neighborIndices[i];
        if (neighborId == index) {
          continue;
        }
        Scalar neighborDist = neighborDistances[i];
        if (neighborDist < separationDistance) {
          Scalar weight = 1.0 - (neighborDist - agentRadius)/(neighborInfluenceRange - agentRadius);
          separationVector += (xfo.tr - previousframe_positions[neighborId]) * ((1.0 / neighborDist) * (separationDistance - neighborDist) * weight);
          neighborInfluenceWeight += 1.0;
        }
      }
      if(displayDebugging){
        debugDraw.drawLine(xfo.tr, xfo.tr+separationVector, Color(0.5, 0.25, 0.0, 1.0));
      }
      if(neighborInfluenceWeight > 0.0){
        separationVector /= neighborInfluenceWeight;
        separationVelocity = separationVector * (separationWeight / timestep);
        goalVelocity += separationVelocity;
      }
    }
  }
  
  Scalar goalSpeed = goalVelocity.length();
  if(goalSpeed > maxLinearVelocity){
    goalVelocity = goalVelocity * (maxLinearVelocity/goalSpeed);
  }
  
  if(displayDebugging){
  //  for (i = 0; i < neighborIndices.size; i++) {
  //    Integer neighborId = neighborIndices[i];
  //    Scalar neighborDist = neighborDistances[i];
  //    if( neighborDist > 0.0 && neighborDist < neighborInfluenceRange){
  //      debugDraw.drawLine(xfo.tr, xfo.tr + ((previousframe_positions[neighborId]-xfo.tr) * 0.47), Color(0.0, 0.25, 0.75, 1.0));
  //    }
  //  }
    
  //  debugDraw.drawLine(previousframe_positions[index], xfo.tr, Color(0.75, 0.0, 0.0, 1.0));
    debugDraw.drawCircle(Xfo(previousframe_positions[index], Quat()), agentRadius, Color(0.5, 0.25, 0.0, 0.5));
    debugDraw.drawCircle(Xfo(previousframe_positions[index], Quat()), neighborInfluenceRange, Color(1.0, 0.25, 0.0, 0.5));
  }
  
}


