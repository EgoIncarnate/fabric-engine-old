//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use FabricMath;
use Vec2, Vec3, Quat, Xfo;
use Color;
use HashTable;
use DebugGeometry;

operator calcCellIndex(
  io Xfo xfo,
  io Vec3 cellcoords,
  io Integer cellindex,
  io HashTable hashtable
) {
  // determine the cell that this particle belongs to.
  cellindex = hashtable.calcCellIndex(xfo.tr, cellcoords);
}

operator populateHashTable(
  io HashTable hashtable,
  io Integer cellIndices<>
) {
  // Reset the hash table, and re-accumulate the ids.
  Size numCells = hashtable.x_count * hashtable.y_count * hashtable.z_count;
  hashtable.cells.resize(numCells);
  for (var Index i = 0; i < numCells; ++ i)
    hashtable.cells[i].resize(0);

  for (var Integer i = 0; i < cellIndices.size; i++) {
    var Integer cellIndex = cellIndices[i];
    hashtable.cells[cellIndex].push(i);
  }
}

operator copyCurrentFrameDataToPrevFrameData(
  io Xfo xfo,
  io Vec3 previousframe_position
) {
  previousframe_position = xfo.tr;
}



operator simulateCrowd(
  in Size index,
  io Boolean initialized,
  io Vec3 goal,
  io Integer cellindex,
  io Vec3 cellcoords,

  io Xfo xfo, /* In theory we don't modify this. Only calculate new movement contols.*/
  io Vec3 velocity,
  io Vec3 previousframe_positions<>,
  io Vec2 maxLinearVelocity,
  io Euler maxAngularVelocity,
  

  io Scalar neighborInfluenceRange,
  io HashTable hashtable,

  io Scalar timestep,

  io Integer neighborIndices[],
  io Scalar neighborDistances[],
  io DebugGeometry debugDraw,
  io Boolean displayDebugging
) {
//  report("simulateCrowd:"+velocity);
  var Integer i;
  /*
  ///////////////////////////////////////////////
  // Broad Phase Interaction Detection
  // This function gathers all the points fomr the current cell, and neighboring cells.
  hashtable.getNeighboringIndices(
    cellindex,
    cellcoords,
    neighborIndices
  );
  
  ///////////////////////////////////////////////
  // Narrow Phase Interaction Detection
  neighborDistances.resize(neighborIndices.size());
  for (i = 0; i < neighborIndices.size; i++) {
    neighborDistances[i] = xfo.tr.distanceTo(previousframe_positions[neighborIndices[i]]);
  }
  */
  debugDraw.reset();

  //////////////////////////////////////////////////////
  // Now we do some simulation

  // Goal Seek
  {
    var Vec3 goalDir = goal - xfo.tr;
    var Scalar goalDist = goalDir.length();

    if (goalDist < neighborInfluenceRange) {
      velocity = velocity.linearInterpolate(Vec3(0.0, 0.0, 0.0), 0.1);
    }
    else {
      velocity = velocity.linearInterpolate(goalDir * Vec3((maxLinearVelocity.x*0.2) / goalDist, 0.0, (maxLinearVelocity.y*0.2) / goalDist), 0.1);
    }
  }
    debugDraw.drawLine(xfo.tr, goal, Color(0.0, 0.5, 0.0, 1.0));

/*
  if (neighborIndices.size > 0) {
    
    //////////////////////////////////////////////////////
    // Separation
    {
      var Scalar separationWeight = 0.05;
      var Scalar separationDistance = neighborInfluenceRange * 0.65;
      var Vec3 separationVector(0.0, 0.0, 0.0);
      for (i = 0; i < neighborIndices.size; i++) {
        var Integer neighborId = neighborIndices[i];
        if (neighborId == index) {
          continue;
        }
        var Scalar neighborDist = neighborDistances[i];

        if (neighborDist == 0.0) {
          // Two particles are sitting on top of each other.
          // We move them to a safe distance appart
          if (neighborId < index) {
            xfo.tr += Vec3(separationDistance * 0.25, 0.0, separationDistance * 0.25);
          }else {
            xfo.tr -= Vec3(separationDistance * 0.25, 0.0, separationDistance * 0.25);
          }
        }
        else if (neighborDist < separationDistance) {
          separationVector += (xfo.tr - previousframe_positions[neighborId]) * ((1.0 / neighborDist) * (separationDistance - neighborDist));
        }
      }
      velocity += separationVector * separationWeight;
    }

  }
*/
  
  // Clamp the particle within the bounds of the hash grid
//  hashtable.clampPosition(xfo.tr);
  
  if(displayDebugging){
    for (i = 0; i < neighborIndices.size; i++) {
      var Integer neighborId = neighborIndices[i];
      var Scalar neighborDist = neighborDistances[i];
      if( neighborDist > 0.0 && neighborDist < neighborInfluenceRange){
        debugDraw.drawLine(xfo.tr, xfo.tr + ((previousframe_positions[neighborId]-xfo.tr) * 0.47), Color(0.0, 0.25, 0.75, 1.0));
      }
    }
    
    debugDraw.drawLine(previousframe_positions[index], xfo.tr, Color(0.75, 0.0, 0.0, 1.0));
    debugDraw.drawCircle(Xfo(previousframe_positions[index], Quat()), neighborInfluenceRange, Color(1.0, 0.25, 0.0, 0.5));
  }
}


