
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//
use Vec2, Vec3, Quat, Xfo;
use LinearKeyframeTrackSet, PoseVariables;
use DebugGeometry;

operator locomotionPreProcessing(/*
  io LinearKeyframeTrackSet sourceAnimationLibrary<>,
  */
  io Bone bones[],
  io Hub hubs[],
  io Limb legs[],
  io COM com,
  io LocomotionFoot locomotionFeet[],
  
  io PoseVariables referenceVariables,
  io KeyframeTrackBindings bindings,
  
  io Scalar sampleFrequency,
  io Scalar movementThreshold,
  
  io LinearKeyframeTrackSet trackSet,
  io LocomotionMarker locomotionMarkers[],
  io FootStepTrack footStepTracks[],
  in Size index,
  
  io DebugGeometry debugGeometry
) {
  report("locomotionPreProcessing:" + index);

  PoseVariables poseVariables = referenceVariables;
  Xfo pose[];
  pose.resize(bones.size);
  for(Integer i=0; i < bones.size; i++){
    pose[i] = bones[i].referencePose;
  }
  Integer currKeys[];
  trackSet.calcTimeRange();
  Vec2 timeRange = trackSet.getTimeRange();
  Integer numSamples = Integer((timeRange.y - timeRange.x) / sampleFrequency);
  
  // Calculate the foot plant time ranges.
  Vec3 footPos[];
  footPos.resize(legs.size);
  Boolean footPlanted[];
  footPlanted.resize(legs.size);
  Vec2 footSteps[][];
  footSteps.resize(legs.size);
  
  for(Integer t=0; t <= numSamples; t++){
    Scalar time = ((Scalar(t)/Scalar(numSamples)) * (timeRange.y - timeRange.x)) + timeRange.x;
    trackSet.evaluateKeyframeTracks(time, bindings, poseVariables, currKeys);
    
    for(Integer i=0; i < legs.size; i++){
      Limb leg = legs[i];
      if(t > 0){
        Scalar dist = (poseVariables.xfoValues[leg.ikGoalXfoId].tr - footPos[i]).length();
        if(t == 1){
          footPlanted[i] = (dist < movementThreshold);
          if(footPlanted[i]){
            footSteps[i].push(Vec2(timeRange.x, 0.0));
          }
        }
        else{
          if(footPlanted[i]){
            if(dist > movementThreshold){
              // Add a foot lift key
              footSteps[i][footSteps[i].size-1].y = time;
              footPlanted[i] = false;
            }
          }
          else{
            if(dist < movementThreshold){
              // Add a foot plant key
              footSteps[i].push(Vec2(time, 0.0));
              footPlanted[i] = true;
            }
          }
        }
      }
      footPos[i] = poseVariables.xfoValues[leg.ikGoalXfoId].tr;
    }
  }
  
  // If a foot was planted at the end of the clip, then its lift time
  for(Integer i=0; i < legs.size; i++){
    Limb leg = legs[i];
    if(footPlanted[i]){
      // This should only be done on looping animations.
      footSteps[i][0].x = -(timeRange.y - footSteps[i][footSteps[i].size-1].x);
      footSteps[i][footSteps[i].size-1].y = (timeRange.y - timeRange.x) + footSteps[i][0].y;
    }
  }
  report("footSteps:"+footSteps);
  
  footStepTracks.resize(legs.size);
  for(Integer i=0; i < legs.size; i++){
    FootStep step;
    if(footSteps[i].size == 1){
      step.liftTime = footSteps[i][0].y - (timeRange.y - timeRange.x);
      step.plantTime = footSteps[i][0].x;
      footStepTracks[i].footSteps.push(step);
      step.liftTime = footSteps[i][0].y;
      step.plantTime = footSteps[i][0].x + (timeRange.y - timeRange.x);
      footStepTracks[i].footSteps.push(step);
    }
    else if(footSteps[i].size == 2){
      step.liftTime = footSteps[i][0].y;
      step.plantTime = footSteps[i][1].x;
      footStepTracks[i].footSteps.push(step);
    }
  
  /*
    for(Integer j=0; j < footSteps[i].size; j++){
      FootStep step;
      if(j==0){
        if(footSteps[i][j].x > 0.0){
          step.liftTime = footSteps[i][footSteps[i].size-1].y - (timeRange.y - timeRange.x);
          step.plantTime = footSteps[i][j].x;
          report("step:"+step);
          footStepTracks[i].footSteps.push(step);
        }
      }
      else if(j == footSteps[i].size-1){
      
      }
      else{
        step.liftTime = footSteps[i][j-1].y;
        step.plantTime = footSteps[i][j].x;
        footStepTracks[i].footSteps.push(step);
      }
    }
    */
  }
  report("footStepTracks:"+footStepTracks);
  
  ///////////////////////////////////////////////////
  // Calculate the COM.
  // Here we build a bindings that will enable us to key just the COM values. 
  KeyframeTrackBindings comParamBindings;
  KeyframeTrackBindings comXfoBindings;
  KeyframeTrackBinding comXfoBinding;
  for(Integer i=0; i < bindings.xfoBindings.size; i++){
    if(bindings.xfoBindings[i].varId == com.xfoId){
    //  comParamBindings.xfoBindings.push(bindings.xfoBindings[i]);
      comXfoBindings.xfoBindings.push(bindings.xfoBindings[i]);
      comXfoBinding = bindings.xfoBindings[i];
    }
  }
  if(comXfoBindings.xfoBindings.size == 0){
    report("COM Xfo variable not found");
    return;
  }
  for(Integer i=0; i < com.parameterVarIds.size; i++){
    for(Integer j=0; j < bindings.scalarBindings.size; j++){
      if(bindings.scalarBindings[j].varId == com.parameterVarIds[i]){
        comParamBindings.scalarBindings.push(bindings.scalarBindings[j]);
      }
    }
  }
  
  Xfo comXfo, prevComXfo;
  Scalar comParams[];
  Integer footId, stepId;
  comParams.resize(com.parameterVarIds.size);  
  Scalar prevKeyt, currKeyt;
  currKeyt = timeRange.x;
  Quat alignment;
  Xfo comAlignment;
  
  Scalar weight = 0.0;
  comAlignment.setIdentity();
  
/*
  for(Integer i=0; i < hubs.size; i++){
    Hub hub = hubs[i];
    
  //  solveHubRig(pose, bones, hub, poseVariables);
  
  //  comAlignment.tr += bones[hub.boneId].referencePose.tr;
  //  weight += 1.0;
    comAlignment.ori = bones[hub.boneId].referencePose.ori;
  }
  for(Integer j=0; j < legs.size; j++){
    Limb leg = legs[j];
    
    comAlignment.tr += leg.ikGoalReferenceXfo.tr;
    weight += 1.0;
  }
  comAlignment.tr *= 1.0/weight;
  comAlignment.ori.setUnit();
*/
  
  comAlignment = bones[hubs[0].boneId].referencePose;
  debugGeometry.drawAxis(comAlignment, 5.0, Color(1.0, 0.0, 1.0, 1.0));
  comAlignment = comAlignment.inverse();
  
    
  comXfo.setIdentity();
//  for(Integer i=0; i < hubs.size; i++){
//    Hub hub = hubs[i];
//    comAlignment = bones[hub.boneId].referencePose.ori;
//  }
//  comAlignment.setUnit();
//  Xfo temp;
//  temp.ori = comAlignment;
//  debugGeometry.drawAxis(temp, 5.0, Color(1.0, 0.0, 1.0, 1.0));
//  comAlignment = comAlignment.inverse();
  
  while(true){
    trackSet.evaluateKeyframeTracks(currKeyt, bindings, poseVariables, currKeys);
    
    /*
    comXfo.setIdentity();
    weight = 0.0;
    for(Integer i=0; i < hubs.size; i++){
      Hub hub = hubs[i];
      pose[hub.boneId] = poseVariables.xfoValues[hub.xfoId];
    //  solveHubRig(pose, bones, hub, poseVariables);
    
    //  comXfo.tr += pose[hub.boneId].tr;
    //  weight += 1.0;
      if(i==0){
        comXfo.ori = pose[hub.boneId].ori;
      }else{
        pose[hub.boneId].ori.alignWith(comXfo.ori);
        comXfo.ori += pose[hub.boneId].ori;
      }
    }
    for(Integer j=0; j < legs.size; j++){
      Limb leg = legs[j];
      comXfo.tr += poseVariables.xfoValues[leg.ikGoalXfoId].tr;
      weight += 1.0;
    }
    comXfo.tr *= 1.0/weight;
    comXfo.ori.setUnit();
    */
    comXfo = poseVariables.xfoValues[hubs[0].xfoId];
    report("comXfo:"+comXfo);
        debugGeometry.drawAxis(comXfo, 10.0, Color(1.0, 0.0, 1.0, 1.0));
    comXfo = comXfo * comAlignment;
  //  debugGeometry.drawAxis(comXfo, 7.0, Color(1.0, 0.0, 1.0, 1.0));
      
    if(currKeyt > timeRange.x){
      Vec3 displacement = (comXfo.tr - prevComXfo.tr);
      comXfo.tr.y = poseVariables.xfoValues[legs[footId].ikGoalXfoId].tr.y;
    
      if(prevKeyt==timeRange.x){
        report("currKeyt:"+prevKeyt);
        prevComXfo.tr.y = poseVariables.xfoValues[legs[footId].ikGoalXfoId].tr.y;
        alignment.setFrom2Vectors(prevComXfo.ori.getZaxis(), displacement.unit());
        prevComXfo.ori = alignment * prevComXfo.ori;
        poseVariables.xfoValues[com.xfoId] = prevComXfo;
        trackSet.setValues(poseVariables, prevKeyt, comXfoBindings);
        
        debugGeometry.drawAxis(prevComXfo, 10.0, Color(1.0, 0.0, 1.0, 1.0));
      }
      report("currKeyt:"+currKeyt);
      
      comXfo.ori.alignWith(prevComXfo.ori);
      Vec3 horizontalDisplacement = displacement;
      horizontalDisplacement.y = 0.0;
      alignment.setFrom2Vectors(prevComXfo.ori.getZaxis(), horizontalDisplacement.unit());
      comXfo.ori = alignment * prevComXfo.ori;
      poseVariables.xfoValues[com.xfoId] = comXfo;
      trackSet.setValues(poseVariables, currKeyt, comXfoBindings);
      debugGeometry.drawAxis(comXfo, 10.0, Color(1.0, 0.0, 1.0, 1.0));
      
      Scalar deltaT = currKeyt - prevKeyt;
      Vec3 velocity = displacement/deltaT;
      Scalar speed = velocity.length();
      Scalar climb = velocity.y;
      velocity.y = 0.0;
      Scalar gradient = climb / velocity.length();
      
      report("velocity:"+velocity);
      Vec3 facingVec = comXfo.ori.rotateVector(Vec3(0.0, 1.0, 0.0));
      facingVec.y = 0.0;
      facingVec.setUnit();
      velocity.setUnit();
      Scalar direction = facingVec.angleTo(velocity);
      if(facingVec.cross(velocity).y > 0.0){
        direction = -direction;
      }
      
      Scalar stepFrequency;
      if(footSteps[footId].size <= 2){
        stepFrequency = timeRange.y - timeRange.x;
      }
      else{
        Vec2 step = footSteps[footId][stepId];
        if(stepId > 0){
          Vec2 prevstep = footSteps[footId][stepId-1];
          stepFrequency = ((step.x + step.y) * 0.5) - ((prevstep.x + prevstep.y) * 0.5);
        }
        else if(stepId < footSteps[footId].size-1){
          Vec2 nextstep = footSteps[footId][stepId+1];
          stepFrequency = ((nextstep.x + nextstep.y) * 0.5) - ((step.x + step.y) * 0.5);
        } 
      }
      
      comParams[0] = stepFrequency;
      comParams[1] = speed;
      comParams[2] = gradient;
      comParams[3] = direction;
      
      for(Integer i=0; i < com.parameterVarIds.size; i++){
        poseVariables.scalarValues[com.parameterVarIds[i]] = comParams[i];
      }
      
      trackSet.setValues(poseVariables, prevKeyt, comParamBindings);
    }
    
    prevComXfo = comXfo;
    
    // Search for the next midplant for any foot.
    
    if(currKeyt >= timeRange.y){
      break;
    }
    prevKeyt = currKeyt;
    
    if(footSteps[0].size <= 2){
      currKeyt = timeRange.y;
    }
    else{
      currKeyt = timeRange.y + 1.0;
      for(Integer i=0; i < legs.size; i++){
        for(Integer j=0; j < footSteps[i].size; j++){
          Vec2 step = footSteps[i][j];
          Scalar midPlant = (step.x + step.y) * 0.5;
          if(midPlant > prevKeyt && midPlant < currKeyt){
            if(midPlant > timeRange.y){
              currKeyt = timeRange.y;
            }else{
              currKeyt = midPlant;
            }
            footId = i;
            stepId = j;
          }
        }
      }
    }
  }
  
  
  for(Integer i=0; i < com.parameterVarIds.size; i++){
    for(Integer j=0; j < bindings.scalarBindings.size; j++){
      if(bindings.scalarBindings[j].varId == com.parameterVarIds[i]){
        report(trackSet.tracks[bindings.scalarBindings[j].trackIds[0]]);
      }
    }
  }
  
//  for(Integer i=0; i < comXfoBinding.trackIds.size; i++){
//    report(trackSet.tracks[comXfoBinding.trackIds[i]]);
//  }
  
  
  ///////////////////////////////////////////////////
  // Finally, modify the hub and foot motions
  LinearKeyframeTrackSet sourceTrackSet = trackSet;//sourceAnimationLibrary[index];
  KeyframeTrackBindings hubValueBindings;
  KeyframeTrackBindings limbValueBindings;
  PoseVariables comVariables = poseVariables;
  Integer comKeyCache[];
  
  for(Integer i=0; i < hubs.size; i++){
    Hub hub = hubs[i];
    for(Integer j=0; j < bindings.xfoBindings.size; j++){
      if(bindings.xfoBindings[j].varId == hub.xfoId){
        hubValueBindings.xfoBindings.push(bindings.xfoBindings[j]);
        trackSet.clearTracks(bindings.xfoBindings[j].trackIds);
      }
    }
  }
  for(Integer i=0; i < locomotionFeet.size; i++){
    LocomotionFoot foot = locomotionFeet[i];
    Limb leg = legs[foot.limbId];
    for(Integer j=0; j < bindings.xfoBindings.size; j++){
      if(bindings.xfoBindings[j].varId == leg.ikGoalXfoId){
        limbValueBindings.xfoBindings.push(bindings.xfoBindings[j]);
        trackSet.clearTracks(bindings.xfoBindings[j].trackIds);
      }
    }
    for(Integer j=0; j < bindings.scalarBindings.size; j++){
      if(bindings.scalarBindings[j].varId == foot.stepTimeVarId){
        limbValueBindings.scalarBindings.push(bindings.scalarBindings[j]);
      }
    }
  }
  
  for(Integer t=0; t <= numSamples; t++){
    Scalar time = ((Scalar(t)/Scalar(numSamples)) * (timeRange.y - timeRange.x)) + timeRange.x;
    sourceTrackSet.evaluateKeyframeTracks(time, bindings, poseVariables, currKeys);
    
    comXfo = poseVariables.xfoValues[com.xfoId];
    for(Integer i=0; i < hubs.size; i++){
      Hub hub = hubs[i];
      Xfo hubXfo = poseVariables.xfoValues[hub.xfoId];
    //  debugGeometry.drawPoint(hubXfo.tr, Color(1.0, 1.0, 0.0, 1.0));
    //  debugGeometry.drawLine(hubXfo.tr, comXfo.tr, Color(1.0, 0.0, 0.0, 1.0));
      poseVariables.xfoValues[hub.xfoId] = comXfo.inverse() * hubXfo;
      trackSet.setValues(poseVariables, time, hubValueBindings);
    }
    
    
    for(Integer i=0; i < locomotionFeet.size; i++){
      LocomotionFoot foot = locomotionFeet[i];
      Limb leg = legs[foot.limbId];
      Xfo footXfo = poseVariables.xfoValues[leg.ikGoalXfoId];
      
      Xfo footInCOMSpace, footComXfo;
      if(leg.hubId < 0){
        footComXfo = comXfo;
      }else{
        footComXfo = comXfo;
        footComXfo.tr.z += poseVariables.xfoValues[hubs[leg.hubId].xfoId].tr.z;
      }
    //  debugGeometry.drawAxis(footComXfo, 10.0, Color(1.0, 1.0, 0.0, 1.0));
      debugGeometry.drawLine(footXfo.tr, footComXfo.tr, Color(1.0, 0.0, 0.0, 1.0));
      footInCOMSpace = footComXfo.inverse() * footXfo;
      
      Scalar stepValue = footInCOMSpace.tr.z - leg.ikGoalReferenceXfo.tr.z;
      footInCOMSpace.tr.z -= stepValue;
      poseVariables.scalarValues[foot.stepTimeVarId] = stepValue;
      poseVariables.xfoValues[leg.ikGoalXfoId] = footInCOMSpace;
    }
    trackSet.setValues(poseVariables, time, limbValueBindings);
    
  }
  trackSet.calcTimeRange();
  
}


