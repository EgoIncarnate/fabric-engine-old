
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//
use Math;
use Vec2, Vec3, Quat, Xfo, Ray;
use PoseVariables, KeyframeTrackBindings;
use DebugGeometry;


function Vec3[][] calcFootPlantTimes(
  in Limb legs[],
  io Vec2 timeRange,
  io Integer leadingFoot,
  io Scalar averageFootPlantTime,
  io Scalar averageFootLiftedTime,
  in Integer numSamples,
  io Scalar movementThreshold,
  
  io PoseVariables poseVariables,
  in KeyframeTrackBindings bindings,
  
  io LinearKeyframeTrackSet trackSet,
  io FootStepTrack footStepTracks[],
  
  io DebugGeometry debugGeometry
){
  Integer currKeys[];
  
  // Calculate the foot plant time ranges.
  Vec3 feetPositions[];
  feetPositions.resize(legs.size);
  Boolean footPlanted[];
  Vec3 footSteps[][];
  Vec3 footPrints[][];
  footPlanted.resize(legs.size);
  footSteps.resize(legs.size);
  footPrints.resize(legs.size);
  Scalar midStepRatio = 0.4;
  
  for(Integer t=0; t <= numSamples; t++){
    Scalar time = ((Scalar(t)/Scalar(numSamples)) * (timeRange.y - timeRange.x)) + timeRange.x;
    poseVariables.evaluateKeyframeTracks(time, trackSet, bindings, currKeys);
    
    for(Integer i=0; i < legs.size; i++){
      Limb leg = legs[i];
      if(t > 0){
        Vec3 footPos = poseVariables.xfoValues[leg.ikGoalXfoId].tr;
        Scalar dist = (footPos - feetPositions[i]).length();
        if(t == 1){
          footPlanted[i] = (dist < movementThreshold);
          if(footPlanted[i]){
            footSteps[i].push(Vec3(timeRange.x, timeRange.x, timeRange.x));
            footPrints[i].push(footPos);
          }
        }
        else{
          if(footPlanted[i]){
            if(dist > movementThreshold){
              // Add a foot lift key
              footSteps[i][footSteps[i].size-1].y = Math_linearInterpolate(footSteps[i][footSteps[i].size-1].x, time, midStepRatio);
              footSteps[i][footSteps[i].size-1].z = time;
              footPlanted[i] = false;
            }
          }
          else{
            if(dist < movementThreshold){
              // Add a foot plant key
              footSteps[i].push(Vec3(time, timeRange.y, timeRange.y));
              footPrints[i].push(footPos);
              footPlanted[i] = true;
            }
          }
        }
      }
      feetPositions[i] = poseVariables.xfoValues[leg.ikGoalXfoId].tr;
    }
  }
  
  report("Detected Footsteps:"+footSteps);
  ///////////////////////////////////////////////////
  averageFootPlantTime = 0.0;
  Scalar numFootPlants = 0.0;
  averageFootLiftedTime = 0.0;
  Scalar numFootLifts = 0.0;
  for(Integer j=0; j < footSteps.size; j++){
    for(Integer i=0; i < footSteps[j].size; i++){
      Vec3 step = footSteps[j][i];
      if(step.x > timeRange.x && step.z < timeRange.y){
        averageFootPlantTime += step.z - step.x;
        numFootPlants += 1.0;
      }
      if(i<footSteps[j].size-1){
        Vec3 nextStep = footSteps[j][i+1];
        averageFootLiftedTime += nextStep.x - step.z;
        numFootLifts += 1.0;
      }
    }
  }
  averageFootPlantTime /= numFootPlants;
  averageFootLiftedTime /= numFootLifts;
  
  report("averageFootPlantTime:"+averageFootPlantTime);
  report("averageFootLiftedTime:"+averageFootLiftedTime);
  
  // If a foot was planted at the end of the clip, then set the plant time as
  for(Integer i=0; i < legs.size; i++){
    Limb leg = legs[i];
    if(footSteps[i][0].x == timeRange.x){
      footSteps[i][0].x = footSteps[i][0].z - averageFootPlantTime;
      footSteps[i][0].y = footSteps[i][0].z - (averageFootPlantTime * (1.0-midStepRatio));
    }
    if(footSteps[i][footSteps[i].size-1].z == timeRange.y){
      footSteps[i][footSteps[i].size-1].z = footSteps[i][footSteps[i].size-1].x + averageFootPlantTime;
      footSteps[i][footSteps[i].size-1].y = footSteps[i][footSteps[i].size-1].x + (averageFootPlantTime * midStepRatio);
    }
  }
  
  report("Cleaned up footSteps:"+footSteps);
  
  ///////////////////////////////////////////////////
  // Find the first foot lift and the last foot lift, and clamp the range.
  Scalar firstFootMidPlant = timeRange.y;
  Scalar lastFootMidPlant = timeRange.x;
  for(Integer i=0; i < legs.size; i++){
    if(footSteps[i].size == 0){
      report("ERROR: No foot steps detected for foot "+i);
      continue;
    }
    if(footSteps[i][0].y < firstFootMidPlant && footSteps[i][0].y > timeRange.x){
      firstFootMidPlant = footSteps[i][0].y;
      leadingFoot = i;
    }
    if(footSteps[i][footSteps[i].size-1].y > lastFootMidPlant && footSteps[i][footSteps[i].size-1].y < timeRange.y){
      lastFootMidPlant = footSteps[i][footSteps[i].size-1].y;
    }
  }
  timeRange.x = firstFootMidPlant;
  timeRange.y = lastFootMidPlant;
  
  report("Clamped timerange:"+timeRange);
  report("leadingFoot:"+leadingFoot);
  
  for(Integer i=0; i < footPrints.size; i++){
    for(Integer j=0; j < footPrints[i].size; j++){
      Xfo xfo;
      xfo.setIdentity();
      xfo.tr = footPrints[i][j];
      debugGeometry.drawCircle(xfo, 0.12, Color(0.0, 0.0, 1.0, 1.0));
    }
  }
  
  ///////////////////////////////////////////////////
  // Convert foot steps into strides.
  footStepTracks.resize(legs.size);
  for(Integer i=0; i < legs.size; i++){
    FootStep step;
    if(footSteps[i][0].y >= timeRange.x){
      Vec3 firstStep = footSteps[i][0];
      step.liftTime = firstStep.x - averageFootLiftedTime;
      step.plantTime = firstStep.x;
      step.midPlantTime = firstStep.y;
      footStepTracks[i].footSteps.push(step);
    }
    for(Integer j=0; j < footSteps[i].size-1; j++){
      step.liftTime = footSteps[i][j].z;
      step.plantTime = footSteps[i][j+1].x;
      step.midPlantTime = footSteps[i][j+1].y;
      footStepTracks[i].footSteps.push(step);
    }
  //  if(footSteps[i][footSteps[i].size-1].x <= timeRange.y){
      Vec3 lastStep = footSteps[i][footSteps[i].size-1];
      step.liftTime = lastStep.z;
      step.plantTime = lastStep.z + averageFootLiftedTime;
      step.midPlantTime = step.plantTime + (averageFootPlantTime * midStepRatio);
      footStepTracks[i].footSteps.push(step);
  //  }
    report("NumSteps:"+footStepTracks[i].footSteps.size);
  }
  report("----");
  report("footStepTracks:"+footStepTracks);
  
  
  return footSteps;
}



operator locomotionPreProcessing(
  io LinearKeyframeTrackSet sourceAnimationLibrary<>,
  io PoseVariables referenceVariables,
  io KeyframeTrackBindings referenceBindings,
  
  io Bone bones[],
  io Hub hubs[],
  io Limb legs[],
  io COM com,
  io LocomotionFoot locomotionFeet[],
  
  io Scalar sampleFrequency,
  io Scalar movementThreshold,
  
  io LinearKeyframeTrackSet trackSet,
  io KeyframeTrackBindings bindings,
  
  io LocomotionMarker locomotionMarkers[][],
  io FootStepTrack footStepTracks[],
  in Size index,
  
  io DebugGeometry debugGeometry
) {
  report("locomotionPreProcessing <<<:" + index);
  
  debugGeometry.reset();
  
  trackSet = sourceAnimationLibrary[index];
  PoseVariables poseVariables = referenceVariables;
  bindings = referenceBindings;
  
  Xfo pose[];
  pose.resize(bones.size);
  for(Integer i=0; i < bones.size; i++){
    pose[i] = bones[i].referencePose;
  }
  Integer currKeys[];
  trackSet.calcTimeRange();
  Vec2 timeRange = trackSet.getTimeRange();
  report("timeRange:"+timeRange);
  Integer numSamples = Integer((timeRange.y - timeRange.x) / sampleFrequency);
  
  Vec3 footSteps[][];
  Integer leadingFoot = 0;
  Scalar averageFootPlantTime;
  Scalar averageFootLiftedTime;
  footSteps = calcFootPlantTimes(
    legs,
    timeRange,
    leadingFoot,
    averageFootPlantTime,
    averageFootLiftedTime,
    numSamples,
    movementThreshold,
    poseVariables,
    bindings,
    trackSet,
    footStepTracks,
    debugGeometry);
    
  
  
  ///////////////////////////////////////////////////
  // Calculate the COM.
  // Here we build a bindings that will enable us to key just the COM values. 
  KeyframeTrackBindings comParamBindings;
  KeyframeTrackBindings comXfoBindings;
  KeyframeTrackBinding comXfoBinding;
  for(Integer i=0; i < bindings.xfoBindings.size; i++){
    if(bindings.xfoBindings[i].varId == com.xfoId){
      comXfoBindings.xfoBindings.push(bindings.xfoBindings[i]);
      comXfoBinding = bindings.xfoBindings[i];
      
      for(Integer j=0; j < comXfoBinding.trackIds.size; j++){
        trackSet.tracks[comXfoBinding.trackIds[j]].clear();
      }
    }
  }
  if(comXfoBindings.xfoBindings.size == 0){
    report("COM Xfo variable not found");
    return;
  }
  for(Integer i=0; i < com.parameterVarIds.size; i++){
    for(Integer j=0; j < bindings.scalarBindings.size; j++){
      if(bindings.scalarBindings[j].varId == com.parameterVarIds[i]){
        comParamBindings.scalarBindings.push(bindings.scalarBindings[j]);
        trackSet.tracks[bindings.scalarBindings[j].trackIds[0]].clear();
      }
    }
  }
  
  Xfo comXfo, prevComXfo;
  Scalar comParams[];
  Integer footId, stepId;
  comParams.resize(com.parameterVarIds.size);  
  Scalar prevKeyt, currKeyt, startT;
  startT = timeRange.x;
  footId = leadingFoot;
  
  prevKeyt = currKeyt = startT;
  
  Quat alignment;
  Xfo comAlignment;
  
  Scalar weight = 0.0;
  comAlignment.setIdentity();
  
  comAlignment = bones[hubs[0].boneId].referencePose;
  Vec3 avgFootPos;
  
  for(Integer j=0; j < legs.size; j++){
    Limb leg = legs[j];
    if(leg.hubId < 0){
      debugGeometry.drawLine(comAlignment.tr, leg.ikGoalReferenceXfo.tr, Color(0.0, 0.0, 0.0, 1.0));
      avgFootPos += leg.ikGoalReferenceXfo.tr;
    //  weight += 1.0;
    }
  }
  if(weight > 0.0){
    avgFootPos *= 1.0/weight;
    alignment.setFrom2Vectors(comAlignment.ori.getXaxis(), Vec3(0.0, 1.0, 0.0));
    comAlignment.ori = alignment * comAlignment.ori;
    comAlignment.tr = avgFootPos;
  }else{
    comAlignment.tr.y = 0.0;
  }
    
  
  comAlignment = comAlignment.inverse();
    
  comXfo.setIdentity();
  Xfo comXfos[];
  Scalar comXfoKeyTimes[];
  while(true){
    report("currKeyt:"+currKeyt + " footId:" + footId + " stepId:"+ stepId);
    poseVariables.evaluateKeyframeTracks(currKeyt, trackSet, bindings, currKeys);
    
    
    comXfo.setIdentity();
    weight = 0.0;
    comXfo = poseVariables.xfoValues[hubs[0].xfoId];
    avgFootPos.setNull();
    for(Integer j=0; j < legs.size; j++){
      Limb leg = legs[j];
      if(leg.hubId < 0){
        avgFootPos += poseVariables.xfoValues[leg.ikGoalXfoId].tr;
      //  weight += 1.0;
      }
    }
    if(weight > 0.0){
      avgFootPos *= 1.0/weight;
      comXfo.tr = avgFootPos;
      alignment.setFrom2Vectors(comXfo.ori.getXaxis(), Vec3(0.0, 1.0, 0.0));
      comXfo.ori = alignment * comXfo.ori;
    }else{
      comXfo.tr.y = 0.0;
    }
    
  
    //////////////////////////////////////
    
    debugGeometry.drawLine(poseVariables.xfoValues[hubs[0].xfoId].tr, comXfo.tr, Color(1.0, 1.0, 1.0, 1.0));
    
    comXfo = comXfo * comAlignment;
    // TODO: raycast the groud plane here. 
    comXfo.tr.y = 0;//poseVariables.xfoValues[legs[footId].ikGoalXfoId].tr.y;
    
    // Force the axis to point straight up. 
    alignment.setFrom2Vectors(comXfo.ori.getYaxis(), Vec3(0.0,1.0,0.0));
    comXfo.ori = alignment * comXfo.ori;
    
    comXfos.push(comXfo);
    comXfoKeyTimes.push(currKeyt);
      
    if(currKeyt > startT){
      Vec3 displacement = comXfo.tr - prevComXfo.tr;
      
      Scalar deltaT = currKeyt - prevKeyt;
      Vec3 velocity = displacement/deltaT;
      Scalar speed = velocity.length();
      Scalar climb = velocity.y;
      velocity.y = 0.0;
      Scalar gradient = climb / velocity.length();
      
      report("velocity:"+velocity);
      Vec3 facingVec = comXfo.ori.rotateVector(Vec3(0.0, 0.0, 1.0));
      facingVec.y = 0.0;
      facingVec.setUnit();
      velocity.setUnit();
      Scalar direction = facingVec.angleTo(velocity);
      if(facingVec.cross(velocity).y > 0.0){
        direction = -direction;
      }
      
      Scalar stepFrequency;
      if(false && footSteps[footId].size <= 2){
        stepFrequency = timeRange.y - timeRange.x;
      }
      else{
        Vec3 step = footSteps[footId][stepId];
        if(stepId > 0){
          Vec3 prevstep = footSteps[footId][stepId-1];
          stepFrequency = step.y - prevstep.y;
        }
        else if(stepId < footSteps[footId].size-1){
          Vec3 nextstep = footSteps[footId][stepId+1];
          stepFrequency = nextstep.y - step.y;
        } 
      }
      
      comParams[0] = stepFrequency;
      comParams[1] = speed;
      comParams[2] = gradient;
      comParams[3] = direction;
      
      for(Integer i=0; i < com.parameterVarIds.size; i++){
        poseVariables.scalarValues[com.parameterVarIds[i]] = comParams[i];
      }
      
      poseVariables.setTrackValues(prevKeyt, trackSet, comParamBindings);
    }
    prevComXfo = comXfo;
    
    // Search for the next midplant for any foot.
    
    if(currKeyt >= timeRange.y){
      break;
    }
    prevKeyt = currKeyt;
    
    if(false && footSteps[0].size <= 2){
      currKeyt = timeRange.y;
    }
    else{
      currKeyt = timeRange.y + 1.0;
      for(Integer i=0; i < legs.size; i++){
        for(Integer j=0; j < footSteps[i].size; j++){
          Vec3 step = footSteps[i][j];
          if(step.y > prevKeyt && step.y < currKeyt){
            currKeyt = step.y;
            footId = i;
            stepId = j;
          }
        }
      }
    }
  }
  
  Vec3 displacement;
  Vec3 alignmentVec;
  Vec3 smoothedComPos;
  Scalar smoothedComPosWeight;
  for(Integer i=0; i < comXfoKeyTimes.size; i++){
    if(i==0){
      displacement = (comXfos[i+1].tr - comXfos[i].tr);
    }else{
      displacement = (comXfos[i].tr - comXfos[i-1].tr);
      comXfos[i].ori.alignWith(comXfos[i-1].ori);
      alignmentVec += (comXfos[i].tr - comXfos[i-1].tr);
    }
    Vec3 horizontalDisplacement = displacement;
    horizontalDisplacement.y = 0.0;
    
    alignmentVec.setNull();
    smoothedComPos = comXfos[i].tr;
    smoothedComPosWeight = 1.0;
    if(i>0){
      alignmentVec += (comXfos[i].tr - comXfos[i-1].tr);
      smoothedComPos += comXfos[i-1].tr;
      smoothedComPosWeight += 1.0;
    }
    if(i<comXfoKeyTimes.size-1){
      alignmentVec += (comXfos[i+1].tr - comXfos[i].tr);
      smoothedComPos += comXfos[i+1].tr;
      smoothedComPosWeight += 1.0;
    }
    smoothedComPos /= smoothedComPosWeight;
    
    comXfo = comXfos[i];
    comXfo.tr = smoothedComPos;
    alignment.setFrom2Vectors(comXfos[i].ori.getZaxis(), alignmentVec.unit());
    comXfo.ori = alignment * comXfos[i].ori;
      
    debugGeometry.drawAxis(comXfo, 1.0, Color(1.0, 0.0, 1.0, 1.0));
    poseVariables.xfoValues[com.xfoId] = comXfo;
    poseVariables.setTrackValues(comXfoKeyTimes[i], trackSet, comXfoBindings);
  }
  
  
  report("com.parameterVarIds:"+com.parameterVarIds);
  report("bindings.scalarBindings:"+bindings.scalarBindings);
  for(Integer i=0; i < com.parameterVarIds.size; i++){
    for(Integer j=0; j < bindings.scalarBindings.size; j++){
      if(bindings.scalarBindings[j].varId == com.parameterVarIds[i]){
        report("---------:"+i);
        report(trackSet.tracks[bindings.scalarBindings[j].trackIds[0]]);
      }
    }
  }
  
//  for(Integer i=0; i < comXfoBinding.trackIds.size; i++){
//    report(trackSet.tracks[comXfoBinding.trackIds[i]]);
//  }
  
  ///////////////////////////////////////////////////
  // Finally, modify the hub and foot motions
  Boolean drawFootMotionDebugging = false;
  LinearKeyframeTrackSet sourceTrackSet = trackSet;//sourceAnimationLibrary[index];
  KeyframeTrackBindings hubValueBindings;
  KeyframeTrackBindings limbValueBindings;
  PoseVariables comVariables = poseVariables;
  Integer comKeyCache[];
  
  for(Integer i=0; i < hubs.size; i++){
    Hub hub = hubs[i];
    for(Integer j=0; j < bindings.xfoBindings.size; j++){
      if(bindings.xfoBindings[j].varId == hub.xfoId){
        hubValueBindings.xfoBindings.push(bindings.xfoBindings[j]);
        trackSet.clearTracks(bindings.xfoBindings[j].trackIds);
      }
    }
  }
  for(Integer i=0; i < locomotionFeet.size; i++){
    LocomotionFoot foot = locomotionFeet[i];
    Limb leg = legs[foot.limbId];
    for(Integer j=0; j < bindings.xfoBindings.size; j++){
      if(bindings.xfoBindings[j].varId == leg.ikGoalXfoId){
        limbValueBindings.xfoBindings.push(bindings.xfoBindings[j]);
        trackSet.clearTracks(bindings.xfoBindings[j].trackIds);
      }
    }
    for(Integer j=0; j < bindings.scalarBindings.size; j++){
      if(bindings.scalarBindings[j].varId == foot.stepTimeVarId){
        limbValueBindings.scalarBindings.push(bindings.scalarBindings[j]);
        trackSet.tracks[bindings.scalarBindings[j].trackIds[0]].clear();
      }
    }
  }
  
  for(Integer t=0; t <= numSamples; t++){
    Scalar time = ((Scalar(t)/Scalar(numSamples)) * (timeRange.y - timeRange.x)) + timeRange.x;
    poseVariables.evaluateKeyframeTracks(time, sourceTrackSet, bindings, currKeys);
    
    comXfo = poseVariables.xfoValues[com.xfoId];
    for(Integer i=0; i < hubs.size; i++){
      Hub hub = hubs[i];
      Xfo hubXfo = poseVariables.xfoValues[hub.xfoId];
      poseVariables.xfoValues[hub.xfoId] = comXfo.inverse() * hubXfo;
      poseVariables.setTrackValues(time, trackSet, hubValueBindings);
      
      
        debugGeometry.drawPoint(hubXfo.tr, Color(1.0, 0.0, 0.0, 1.0));
    }
    
    
    for(Integer i=0; i < locomotionFeet.size; i++){
      LocomotionFoot foot = locomotionFeet[i];
      Limb leg = legs[foot.limbId];
      Xfo footXfo = poseVariables.xfoValues[leg.ikGoalXfoId];
      
      // TODO: calculate the displacementDir based on the com movement;
      Vec3 displacementDir(0.0,0.0,1.0);
      Xfo footParentSpaceXfo;
      if(leg.hubId < 0){
        footParentSpaceXfo = comXfo;
      }
      else{
        Xfo hubXfo = poseVariables.xfoValues[hubs[leg.hubId].xfoId];
        hubXfo.tr.z += comXfo.tr.z;
        footParentSpaceXfo = hubXfo;
      }
      if(drawFootMotionDebugging){
        debugGeometry.drawLine(footXfo.tr, footParentSpaceXfo.tr, Color(1.0, 0.0, 0.0, 1.0));
      }
      
      Xfo baseFootXfo = footParentSpaceXfo * leg.ikGoalReferenceXfo;
      baseFootXfo.ori = comXfo.ori;
      if(drawFootMotionDebugging){
        debugGeometry.drawLine(footXfo.tr, baseFootXfo.tr, Color(0.5, 0.5, 0.75, 1.0));
      }
      Scalar stepValue = (footXfo.tr - baseFootXfo.tr).dot(displacementDir);
      
      footXfo.tr -= displacementDir * stepValue;
      if(drawFootMotionDebugging){
        debugGeometry.drawLine(footXfo.tr, comXfo.tr, Color(0.0, 0.0, 0.0, 1.0));
      }
      
      Xfo footMotionDelta = footParentSpaceXfo.inverse() * footXfo;
      
      poseVariables.scalarValues[foot.stepTimeVarId] = stepValue;
      poseVariables.xfoValues[leg.ikGoalXfoId] = footMotionDelta;
    }
    poseVariables.setTrackValues(time, trackSet, limbValueBindings);
  }
  
  ///////////////////////////////////////////////////
  // Add Animation Markers
  locomotionMarkers.resize(legs.size);
  for(Integer i=0; i < legs.size; i++){
        report("processing leg:"+i);
    for(Integer j=0; j < footStepTracks[i].footSteps.size; j++){
      if(footStepTracks[i].footSteps[j].midPlantTime < timeRange.x ||
         footStepTracks[i].footSteps[j].midPlantTime >= timeRange.y){
        continue;
      }
      // This is just temporary. Only enable one marker per foot.
      if(locomotionMarkers[i].size > 0){
        continue;
      }
      LocomotionMarker marker;
      Scalar t = footStepTracks[i].footSteps[j].midPlantTime;
      marker.time = t;
    //  marker.stepId = j;
      
      poseVariables.evaluateKeyframeTracks(t, trackSet, comParamBindings, currKeys);
      marker.params.resize(comParamBindings.scalarBindings.size);
      for(Integer k=0; k < comParamBindings.scalarBindings.size; k++){
        marker.params[k] = poseVariables.scalarValues[comParamBindings.scalarBindings[k].varId];
      }
      report(marker);
      marker.stepIds.resize(legs.size);
      for(Integer k=0; k < legs.size; k++){
        marker.stepIds[k] = -1;
      }
      // for this marker, find all the foot step ids that are valid for the other legs.
      for(Integer k=0; k < legs.size; k++){
        report("searching leg:"+k);
        if(k==j){
          marker.stepIds[j] = j;
        }
        else{
          // Plant times dictate stepId increments, we must find the step that
          // plants after the current foot lift. 
          for(Integer l=0; l < footStepTracks[k].footSteps.size; l++){
            report("step"+l+":"+footStepTracks[k].footSteps[l]);
            if(footStepTracks[k].footSteps[l].midPlantTime > t){
              marker.stepIds[k] = l;
              break;
            }
          }
        }
      }
      report("marker.stepIds:"+marker.stepIds);
      
      locomotionMarkers[i].push(marker);
    }
  }
  report("locomotionMarkers:"+locomotionMarkers);
  
  trackSet.timeRange = timeRange;
  
  report("locomotionPreProcessing >>>:" + index);
}


