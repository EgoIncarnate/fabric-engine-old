//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Xfo, OGLShaderProgram;

operator preSliceRender(io OGLShaderProgram shaderProgram) {
  Mat44 mat44;
  mat44.setIdentity();
  Mat33 mat33;
  mat33.setIdentity();
  Integer location = shaderProgram.getUniformLocation( NORMALMATRIX_ATTRIBUTE_ID );
  if(location!=-1)
    shaderProgram.loadMat33Uniform(location, mat33);
  location = shaderProgram.getUniformLocation( MODELVIEWPROJECTION_MATRIX_ATTRIBUTE_ID );
  if(location!=-1)
    shaderProgram.loadMat44Uniform(location, mat44);
  location = shaderProgram.getUniformLocation( MODELVIEW_MATRIX_ATTRIBUTE_ID );
  if(location!=-1)
    shaderProgram.loadMat44Uniform(location, mat44);
  glPushAttrib(GL_ENABLE_BIT | GL_DEPTH_BUFFER_BIT);
  glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);
}

operator postSliceRender() {
  glPopClientAttrib();
  glPopAttrib();
}

operator draw2DVolumeSlice(
  io Xfo volumeXfo,
  io Size axis,
  io Scalar ratio,
  io Vec2 tl,
  io Vec2 br,
  io OGLShaderProgram shaderProgram
){
  String name = 'a_position';
  Integer posLocation = glGetAttribLocation(shaderProgram.programId, name);
  name = 'a_normal';
  Integer tex3DLocation = glGetAttribLocation(shaderProgram.programId, name);

  Vec3 p[4];
  p[0] = Vec3(tl.x, tl.y, 0.0);
  p[1] = Vec3(br.x, tl.y, 0.0);
  p[2] = Vec3(br.x, br.y, 0.0);
  p[3] = Vec3(tl.x, br.y, 0.0);
  
  Vec3 texCoords[2];
  texCoords[0] = Vec3( 0.0, 0.0, 0.0 );
  texCoords[1] = Vec3( 1.0, 1.0, 1.0 );

  Scalar fixedRatio = ratio;

  //Rotate axis; 3D texture is not necessarily aligned with global axis
  Size i;
  for(i = 0; i <2; ++i)
    texCoords[i] = volumeXfo.ori.inverse().rotateVector(texCoords[i]);

  for(i = 0; i < 3; ++i) {
    if( ( texCoords[0].component(i) + texCoords[1].component(i) ) < 0.0 ) {
      texCoords[0].setComponent(i, 1.0+texCoords[0].component(i));
      texCoords[1].setComponent(i, 1.0+texCoords[1].component(i));
      if(axis == i)
        fixedRatio = 1.0 - fixedRatio;
    }
  }

  Vec3 t[4];
  if(axis == 0) {
    t[0] = Vec3(fixedRatio, texCoords[0].y, texCoords[1].z);
    t[1] = Vec3(fixedRatio, texCoords[1].y, texCoords[1].z);
    t[2] = Vec3(fixedRatio, texCoords[1].y, texCoords[0].z);
    t[3] = Vec3(fixedRatio, texCoords[0].y, texCoords[0].z);
  } else if(axis == 1) {
    t[0] = Vec3(texCoords[0].x, fixedRatio, texCoords[1].z);
    t[1] = Vec3(texCoords[1].x, fixedRatio, texCoords[1].z);
    t[2] = Vec3(texCoords[1].x, fixedRatio, texCoords[0].z);
    t[3] = Vec3(texCoords[0].x, fixedRatio, texCoords[0].z);
  } else { //Z is flipped
    t[0] = Vec3(texCoords[0].x, texCoords[0].y, fixedRatio);
    t[1] = Vec3(texCoords[1].x, texCoords[0].y, fixedRatio);
    t[2] = Vec3(texCoords[1].x, texCoords[1].y, fixedRatio);
    t[3] = Vec3(texCoords[0].x, texCoords[1].y, fixedRatio);
  }
  
  Integer idx[4];
  idx[0] = 0; idx[1] = 1; idx[2] = 2; idx[3] = 3;

  Data NULL;

  Size bufferIDArray[];
  bufferIDArray.resize(1);

  glGenBuffers(1, bufferIDArray);
  Size bufferID0 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  Size bufferID1 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  Size bufferID2 = bufferIDArray[0];
  
  glBindBuffer(GL_ARRAY_BUFFER, bufferID0);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID1);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(tex3DLocation);
  glVertexAttribPointer(tex3DLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID2);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID2);
  glDrawElements(GL_QUADS, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  bufferIDArray[0] = bufferID0; glDeleteBuffers(1, bufferIDArray);
  bufferIDArray[0] = bufferID1; glDeleteBuffers(1, bufferIDArray);
  bufferIDArray[0] = bufferID2; glDeleteBuffers(1, bufferIDArray);
}
