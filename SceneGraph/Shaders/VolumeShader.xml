<?xml version="1.0" encoding="UTF-8"?>
<shader>
	<name>VolumeMaterial</name>
	
  <uniforms>
    <uniform name="u_alphaFactor" constant="alphaFactor" type="Scalar" defaultValue="0.02"/>
    <uniform name="u_transparency" constant="transparency" type="Scalar" defaultValue="1.0"/>
    <uniform name="u_brightness" constant="brightness" type="Scalar" defaultValue="0.5"/>
    <uniform name="u_minOpacity" constant="minOpacity" type="Scalar" defaultValue="0.0"/>
    <uniform name="u_maxOpacity" constant="maxOpacity" type="Scalar" defaultValue="1.0"/>
    <uniform name="u_invertColor" constant="invertColor" type="Integer" defaultValue="0"/>
    <uniform name="u_specularFactor" constant="scaledSpecularFactor" type="Scalar" defaultValue="1.0"/>

    <uniform name="u_lightPosition" constant="lightPosition" type="Vec3" owner="light"/>

    <uniform name="u_materialShininess" constant="shininess" type="Scalar" defaultValue="10.0"/>

    <uniform name="u_samplerOpacityMap" constant="opacityTexture" type="Integer" owner="texture"/>
    <uniform name="u_samplerGradientMap" constant="gradientTexture" type="Integer" owner="texture"/>
    <uniform name="u_samplerTransferFunctionMap" constant="transferFunctionTexture" type="Integer" owner="texture"/>

    <uniform name="u_modelViewProjectionMatrix" constant="modelViewProjectionMatrix" type="Mat44" owner="instance"/>
    <uniform name="u_modelViewMatrix" constant="modelViewMatrix" type="Mat44" owner="instance"/>
    <uniform name="u_normalMatrix" constant="normalMatrix" type="Mat33" owner="instance"/>

  </uniforms>

  <attributes>
		<attribute name="a_position" binding="positions"/>
    <attribute name="a_normal" binding="normals"/>
  </attributes>

  <lights>
    <light type="Light" binding="light"/>
  </lights>

	<textures>
    <texture binding="opacityTexture"/>
    <texture binding="gradientTexture"/>
    <texture binding="transferFunctionTexture"/>
  </textures>

  <openglstateparams>
    <enableOptions>
      <option>GL_BLEND</option>
    </enableOptions>
    <blendModeSfactor>GL_SRC_ALPHA</blendModeSfactor>
    <blendModeDfactor>GL_ONE_MINUS_SRC_ALPHA</blendModeDfactor>
  </openglstateparams>

  <vertexshader>
		<source>
			<![CDATA[
			uniform mat4 u_modelViewProjectionMatrix;
			uniform mat4 u_modelViewMatrix;
			uniform vec4 u_lightPosition;

			attribute vec4 a_position;
			attribute vec3 a_normal;

			varying vec3 lightDir;
			varying vec3 viewDir;

			void main()
			{
				gl_TexCoord[0].xyz = a_normal.xyz;

				vec4 modelCameraPosition = u_modelViewMatrix * a_position;
				lightDir = vec3(u_lightPosition - modelCameraPosition);
				viewDir = vec3(-modelCameraPosition);
				gl_Position = u_modelViewProjectionMatrix * a_position;
			}
			]]>
		</source>
	</vertexshader>
	
	<fragmentshader>
		<source>
			<![CDATA[
      uniform float u_alphaFactor;
      uniform float u_transparency;
      uniform float u_brightness;
      uniform float u_minOpacity;
      uniform float u_maxOpacity;
      uniform int u_invertColor;

      uniform float u_specularFactor;
			uniform mat3 u_normalMatrix;
			uniform float u_materialShininess;

			uniform sampler3D u_samplerOpacityMap;
			uniform sampler3D u_samplerGradientMap;
      uniform sampler2D u_samplerTransferFunctionMap;
      
			varying vec3 lightDir;
			varying vec3 viewDir;

			void main(){

        //Lighting computations
				vec3 Ln = normalize(lightDir);
				vec3 Vn = normalize(viewDir);

        float opacity = texture3D( u_samplerOpacityMap, gl_TexCoord[0].xyz).r;
        vec4 gradient = texture3D( u_samplerGradientMap, gl_TexCoord[0].xyz);
        vec4 transferFunction = texture2D( u_samplerTransferFunctionMap, vec2(opacity, 0.5) );

        //Opacity & alpha modulation
        if(opacity < u_minOpacity || opacity > u_maxOpacity)
          opacity = 0.0;
        else
          opacity = transferFunction.a * u_brightness;//(opacity - u_minOpacity)*(u_maxOpacity - u_minOpacity);//Should we rescale??

        transferFunction.rgb *= u_brightness;

        float alpha = min( mix(1.0-u_transparency, opacity * u_alphaFactor, u_transparency ), 1.0 );

        //TODO: we should use transferFunction.a's derivative (should be pre-computed in a texture)
        //TODO2: this should be proportional to opacity??? Not sure; we like the glass look...
        float gradientWeight = gradient.a;
        if(opacity == 0.0) {
          alpha = 0.0;
          gradientWeight = 0.0;
        }

        //TODO: invert: invert only color intensity, eg: light red -> dark red
				vec4 volumeColor = u_invertColor == 0 ? 
                              min( vec4(transferFunction.rgb, alpha ), vec4(1.0, 1.0, 1.0, 1.0) ) : 
                              max( vec4(1.0-transferFunction.r, 1.0-transferFunction.g, 1.0-transferFunction.b, alpha ), vec4(0.0, 0.0, 0.0, 0.0) );
        
        //Point light phong shading with additive-only specular
				vec3 Nn = normalize( u_normalMatrix * (gradient.xyz - vec3(0.5, 0.5, 0.5)) );
        vec4 shadedColor = volumeColor;

        //float lightBehind = dot(Nn,Ln);
        vec3 Rn = reflect(-Ln, Nn);
        float specular = pow( max(dot(Rn, Vn), 0.0), u_materialShininess );

        float specColor = specular * u_specularFactor * gradientWeight;
        shadedColor.a += min( shadedColor.a+specColor, 1.0 );
        if(shadedColor.a > 0.0001)
          specColor /= shadedColor.a;//Try to maintain specular contibution no matter how much alpha
        shadedColor.rgb += vec3( specColor, specColor, specColor );
        shadedColor.a = min( shadedColor.a, 1.0 );
        gl_FragColor = shadedColor;
      }
			]]>
		</source>
	</fragmentshader>
</shader>
