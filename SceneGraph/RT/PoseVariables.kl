//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Math, Vec3, Euler, Quat;
use LinearKeyframe;
use LinearKeyframeTrack;
use LinearKeyframeTrackSet;

function PoseVariables.addScalarValue(){
  this.scalarValues.push(0.0);
}

function PoseVariables.addXfoValue() {
  Xfo xfo;
  this.xfoValues.push(xfo);
}


function PoseVariables.evaluateKeyframeTracks(
  in LinearKeyframeTrackSet trackSet,
  in Scalar time,
  in KeyframeTrackBindings bindings,
  io Integer currKeys[]
) {
  Integer trackId = 0;
  if (currKeys.size < trackId + bindings.scalarBindings.size){
    currKeys.resize(trackId + bindings.scalarBindings.size);
  }
  for (Integer i = 0; i < bindings.scalarBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.scalarBindings[i];
    this.scalarValues[binding.varId] = trackSet.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]);
  }
  for (Integer i = 0; i < bindings.quatBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.quatBindings[i];
    if(binding.trackIds.size != 3 && binding.trackIds.size != 4){
      report('incorrect binding for Quat:' + binding);
      continue;
    }
    if(currKeys.size < trackId + binding.trackIds.size){
      currKeys.resize(trackId + binding.trackIds.size);
    }
    if(binding.trackIds.size == 3){
      // Euler to Quat
      Euler euler(Vec3( trackSet.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
                        trackSet.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
                        trackSet.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++])));
      this.quatValues[binding.varId].setFromEuler(euler);
    }
    else if(binding.trackIds.size == 4){
      this.quatValues[binding.varId].set(
        trackSet.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++])
      );
    }
  }
  
  for (Integer i = 0; i < bindings.xfoBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.xfoBindings[i];
  //  if(binding.trackIds.size != 7){
  //    report('incorrect binding for Xfo:' + binding);
  //    continue;
  //  }
    if(currKeys.size < trackId + binding.trackIds.size){
      currKeys.resize(trackId + binding.trackIds.size);
    }
    // If the bindings 3 or 4, we assume an fk rotation animation is bound.
    // this isn't the safest assumption, and probably should be made explicit.
    if(binding.trackIds.size == 3){
      Euler euler(Vec3( trackSet.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
                        trackSet.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
                        trackSet.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++])));
      this.xfoValues[binding.varId].ori.setFromEuler(euler);
    }
    else if(binding.trackIds.size == 4){
      this.xfoValues[binding.varId].ori.set(
        trackSet.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++])
      );
    }
    else if(binding.trackIds.size == 6 || binding.trackIds.size == 7){
      this.xfoValues[binding.varId].tr.set(
        trackSet.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
        trackSet.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++])
      );
      if(binding.trackIds.size == 6){
        Euler euler(Vec3( trackSet.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++]),
                          trackSet.tracks[binding.trackIds[4]].evaluate(time, currKeys[trackId++]),
                          trackSet.tracks[binding.trackIds[5]].evaluate(time, currKeys[trackId++])));
        this.xfoValues[binding.varId].ori.setFromEuler(euler);
      }
      else if(binding.trackIds.size == 7){
        this.xfoValues[binding.varId].ori.set(
          trackSet.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++]),
          trackSet.tracks[binding.trackIds[4]].evaluate(time, currKeys[trackId++]),
          trackSet.tracks[binding.trackIds[5]].evaluate(time, currKeys[trackId++]),
          trackSet.tracks[binding.trackIds[6]].evaluate(time, currKeys[trackId++])
        );
      }
    }
  }
}

