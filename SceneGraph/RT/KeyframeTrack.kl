
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use KEYFRAMETYPE;

function KEYFRAMETYPETrack.clear() {
  this.keys.resize(0);
}


function Scalar KEYFRAMETYPETrack.evaluate(
  in Scalar time,
  io Integer keyIndex
) {
  Integer numKeys = this.keys.size;
  if(numKeys == 0){
    return 0.0;
  }
  else if(numKeys == 1){
    return this.keys[0].value;
  }
  else if (time >= this.keys[numKeys - 1].time) {
    return this.keys[numKeys - 1].value;
  }
  else if (time <= this.keys[0].time) {
    return this.keys[0].value;
  }
  else {
    if (this.keys[keyIndex].time <= time && time <= this.keys[keyIndex + 1].time) {
      // we are still on the same segment as the previous evaluation.
    }
    else if (this.keys[keyIndex + 1].time < time && time < this.keys[keyIndex + 2].time) {
      keyIndex++;
    }
    else {
      for (var Integer i = 0; i < numKeys - 1; i++) {
        if (this.keys[i].time <= time && time <= this.keys[i + 1].time) {
          keyIndex = i;
          break;
        }
      }
    }
    return this.keys[keyIndex].interpolate(this.keys[keyIndex + 1], time);
  }
}
/*
Note: this function caused a wierd compiler error.
TODO: log a bug.
function Scalar KEYFRAMETYPETrack.evaluate(
  in Scalar time
) {
  Integer keyIndex = 0;
  return KEYFRAMETYPETrack.evaluate(time, keyIndex);
}
*/

function KEYFRAMETYPETrack.setValue(
  in Scalar time,
  in Scalar value
) {
  Integer numKeys = this.keys.size;
  if (numKeys == 0 || time > this.keys[numKeys - 1].time) {
    this.keys.push(KEYFRAMETYPE(time, value));
  }
  else {
    Integer keyIndex = -1;
    for (var Integer i = 0; i < numKeys; i++) {
      if (this.keys[i].time == time) {
        keyIndex = i;
        break;
      }
    }
    if(keyIndex != -1){
      this.keys[keyIndex].value = value;
    }
    else{
      // This ensures that the last key always has the greatest time value.
      // this optimizes the common case where we are incrementaly keying 
      // forwards through time. 
      this.keys.push(this.keys[numKeys - 1]);
      this.keys[numKeys - 1] = KEYFRAMETYPE(time, value);
      // needs sorting == true
    }
  }
}

/////////////////////////////////////////////////
// KEYFRAMETYPETrackSet
use Color, Vec3, Quat, Xfo;


function KEYFRAMETYPETrackSet.addTrack(
  in String name,
  in Color color,
  io Integer trackId
){
  trackId = this.tracks.size;
  this.tracks.resize(trackId+1);
  this.tracks[trackId].name = name;
  this.tracks[trackId].color = color;
}

function KEYFRAMETYPETrackSet.addXfoTracks(
  in String name,
  in Boolean storeEulerAngles,
  io Integer binding[]
){
  Integer trackId;
  Color red(1.0, 0.0, 0.0, 1.0);
  Color green(0.0, 0.0, 0.0, 1.0);
  Color blue(0.0, 0.0, 1.0, 1.0);
  Color cyan(0.0, 1.0, 1.0, 1.0);
  this.addTrack(name+'tr.x', red, trackId);   binding.push(trackId);
  this.addTrack(name+'tr.y', green, trackId); binding.push(trackId);
  this.addTrack(name+'tr.z', blue, trackId);  binding.push(trackId);
  
  if(storeEulerAngles){
    this.addTrack(name+'euler.x', red, trackId);   binding.push(trackId);
    this.addTrack(name+'euler.y', green, trackId); binding.push(trackId);
    this.addTrack(name+'euler.z', blue, trackId);  binding.push(trackId);
  }
  else{
    this.addTrack(name+'ori.x', red, trackId);   binding.push(trackId);
    this.addTrack(name+'ori.y', green, trackId); binding.push(trackId);
    this.addTrack(name+'ori.z', blue, trackId);  binding.push(trackId);
    this.addTrack(name+'ori.z', cyan, trackId);  binding.push(trackId);
  }
}


function Vec2 KEYFRAMETYPETrackSet.getTimeRange() {
  return this.timeRange;
}

function KEYFRAMETYPETrackSet.calcTimeRange() {
  this.timeRange.set(0.0, 0.0);
  for (Integer i = 0; i < this.tracks.size; i++) {
    if(this.tracks[i].keys.size == 0){
      continue;
    }
    if(i==0){
      this.timeRange.x = this.tracks[i].keys[0].time;
      this.timeRange.y = this.tracks[i].keys[this.tracks[i].keys.size-1].time;
    }
    else{
      if(this.timeRange.x > this.tracks[i].keys[0].time){
        this.timeRange.x = this.tracks[i].keys[0].time;
      }
      if(this.timeRange.y < this.tracks[i].keys[this.tracks[i].keys.size-1].time){
        this.timeRange.y = this.tracks[i].keys[this.tracks[i].keys.size-1].time;
      }
    }
  }
}


function KEYFRAMETYPETrackSet.clearTracks(
  Integer trackIds[]
) {
  for (Integer i = 0; i < trackIds.size; i++) {
    this.tracks[trackIds[i]].clear();
  }
}


function KEYFRAMETYPETrackSet.setValues(
  io PoseVariables values,
  in Scalar time,
  io KeyframeTrackBindings bindings
) {
  for (Integer i = 0; i < bindings.scalarBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.scalarBindings[i];
    if(binding.trackIds.size == 1){
      Scalar val = values.scalarValues[binding.varId];
      this.tracks[binding.trackIds[0]].setValue(time, val);
    }
  }
  
  for (Integer i = 0; i < bindings.quatBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.quatBindings[i];
    if(binding.trackIds.size == 3){
      //  Quat to Euler
      report("TODO:Euler.setFromQuat");
    //  Euler euler;
    //  euler.setFromQuat(values.quatValues[binding.varId]);
    //  this.tracks[binding.trackIds[0]].setValue(time, euler.x),
    //  this.tracks[binding.trackIds[1]].setValue(time, euler.y),
    //  this.tracks[binding.trackIds[2]].setValue(time, euler.z)));
    }
    else if(binding.trackIds.size == 4){
      Quat q = values.quatValues[i];
      this.tracks[binding.trackIds[0]].setValue(time, q.v.x );
      this.tracks[binding.trackIds[1]].setValue(time, q.v.y );
      this.tracks[binding.trackIds[2]].setValue(time, q.v.z );
      this.tracks[binding.trackIds[3]].setValue(time, q.w );
    }
  }
  
  for (Integer i = 0; i < bindings.xfoBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.xfoBindings[i];
    if(binding.trackIds.size != 7){
      report('incorrect binding for Xfo:' + binding);
      continue;
    }
    Xfo xfo = values.xfoValues[binding.varId];
    
    this.tracks[binding.trackIds[0]].setValue(time, xfo.tr.x);
    this.tracks[binding.trackIds[1]].setValue(time, xfo.tr.y);
    this.tracks[binding.trackIds[2]].setValue(time, xfo.tr.z);
    
    if(binding.trackIds.size == 6){
      //  Quat to Euler
      report("TODO:Euler.setFromQuat");
    //  Euler euler;
    //  euler.setFromQuat(xfo.ori);
    //  this.tracks[binding.trackIds[0]].setValue(time, euler.x),
    //  this.tracks[binding.trackIds[1]].setValue(time, euler.y),
    //  this.tracks[binding.trackIds[2]].setValue(time, euler.z)));
    }else if(binding.trackIds.size == 7){
      this.tracks[binding.trackIds[3]].setValue(time, xfo.ori.v.x);
      this.tracks[binding.trackIds[4]].setValue(time, xfo.ori.v.y);
      this.tracks[binding.trackIds[5]].setValue(time, xfo.ori.v.z);
      this.tracks[binding.trackIds[6]].setValue(time, xfo.ori.w);
    }
  }
}



function KEYFRAMETYPETrackSet.evaluateKeyframeTracks(
  in Scalar time,
  in KeyframeTrackBindings bindings,
  io PoseVariables poseVariables,
  io Integer currKeys[]
) {
  Integer trackId = 0;
  if (currKeys.size < trackId + bindings.scalarBindings.size){
    currKeys.resize(trackId + bindings.scalarBindings.size);
  }
  for (Integer i = 0; i < bindings.scalarBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.scalarBindings[i];
    poseVariables.scalarValues[binding.varId] = this.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]);
  }
  for (Integer i = 0; i < bindings.quatBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.quatBindings[i];
    if(binding.trackIds.size != 3 && binding.trackIds.size != 4){
      report('incorrect binding for Quat:' + binding);
      continue;
    }
    if(currKeys.size < trackId + binding.trackIds.size){
      currKeys.resize(trackId + binding.trackIds.size);
    }
    if(binding.trackIds.size == 3){
      // Euler to Quat
      Euler euler(Vec3( this.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
                        this.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
                        this.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++])));
      poseVariables.quatValues[binding.varId].setFromEuler(euler);
    }
    else if(binding.trackIds.size == 4){
      poseVariables.quatValues[binding.varId].set(
        this.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++])
      );
    }
  }
  
  for (Integer i = 0; i < bindings.xfoBindings.size; i++) {
    KeyframeTrackBinding binding = bindings.xfoBindings[i];
  //  if(binding.trackIds.size != 7){
  //    report('incorrect binding for Xfo:' + binding);
  //    continue;
  //  }
    if(currKeys.size < trackId + binding.trackIds.size){
      currKeys.resize(trackId + binding.trackIds.size);
    }
    // If the bindings 3 or 4, we assume an fk rotation animation is bound.
    // this isn't the safest assumption, and probably should be made explicit.
    if(binding.trackIds.size == 3){
      Euler euler(Vec3( this.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
                        this.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
                        this.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++])));
      poseVariables.xfoValues[binding.varId].ori.setFromEuler(euler);
    }
    else if(binding.trackIds.size == 4){
      poseVariables.xfoValues[binding.varId].ori.set(
        this.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++])
      );
    }
    else if(binding.trackIds.size == 6 || binding.trackIds.size == 7){
      poseVariables.xfoValues[binding.varId].tr.set(
        this.tracks[binding.trackIds[0]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[1]].evaluate(time, currKeys[trackId++]),
        this.tracks[binding.trackIds[2]].evaluate(time, currKeys[trackId++])
      );
      if(binding.trackIds.size == 6){
        Euler euler(Vec3( this.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++]),
                          this.tracks[binding.trackIds[4]].evaluate(time, currKeys[trackId++]),
                          this.tracks[binding.trackIds[5]].evaluate(time, currKeys[trackId++])));
        poseVariables.xfoValues[binding.varId].ori.setFromEuler(euler);
      }
      else if(binding.trackIds.size == 7){
        poseVariables.xfoValues[binding.varId].ori.set(
          this.tracks[binding.trackIds[3]].evaluate(time, currKeys[trackId++]),
          this.tracks[binding.trackIds[4]].evaluate(time, currKeys[trackId++]),
          this.tracks[binding.trackIds[5]].evaluate(time, currKeys[trackId++]),
          this.tracks[binding.trackIds[6]].evaluate(time, currKeys[trackId++])
        );
      }
    }
  }
}