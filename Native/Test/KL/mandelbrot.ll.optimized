; ModuleID = 'kl'

%0 = type { i32, i32, i32, [5 x i8] }
%1 = type { i32, i32, i32, [6 x i8] }
%2 = type { i32, i32, i32, [26 x i8] }
%3 = type { i32, i32, i32, [29 x i8] }
%4 = type { i32, i32, i32, [39 x i8] }
%5 = type { i32, i32, i32, [35 x i8] }
%6 = type { i32, i32, i32, [41 x i8] }
%7 = type { i32, i32, i32, [2 x i8] }
%String = type %StringBits*
%StringBits = type { i32, i32, i32, [0 x i8] }
%cl_device_id_VA = type %cl_device_id_VABits*
%cl_device_id_VABits = type { i32, i32, i32, [0 x i8*] }

@0 = internal constant %0 { i32 -2147483648, i32 5, i32 4, [5 x i8] c"true\00" }
@1 = internal constant %1 { i32 -2147483648, i32 6, i32 5, [6 x i8] c"false\00" }
@__Byte__Adapter = external constant i8*
@2 = internal constant %2 { i32 -2147483648, i32 26, i32 25, [26 x i8] c"KL: Byte division by zero\00" }
@3 = internal constant %2 { i32 -2147483648, i32 26, i32 25, [26 x i8] c"KL: Byte division by zero\00" }
@__Data__Adapter = external constant i8*
@__Integer__Adapter = external constant i8*
@4 = internal constant %3 { i32 -2147483648, i32 29, i32 28, [29 x i8] c"KL: Integer division by zero\00" }
@5 = internal constant %3 { i32 -2147483648, i32 29, i32 28, [29 x i8] c"KL: Integer division by zero\00" }
@__Scalar__Adapter = external constant i8*
@__Size__Adapter = external constant i8*
@6 = internal constant %2 { i32 -2147483648, i32 26, i32 25, [26 x i8] c"KL: Size division by zero\00" }
@7 = internal constant %2 { i32 -2147483648, i32 26, i32 25, [26 x i8] c"KL: Size division by zero\00" }
@__cl_command_queue__Adapter = external constant i8*
@__cl_context__Adapter = external constant i8*
@__cl_device_id__Adapter = external constant i8*
@8 = internal constant %4 { i32 -2147483648, i32 39, i32 38, [39 x i8] c"KL: cl_device_id[] index out-of-bounds\00" }
@__cl_device_id_VA__Adapter = external constant i8*
@9 = internal constant %4 { i32 -2147483648, i32 39, i32 38, [39 x i8] c"KL: cl_device_id[] index out-of-bounds\00" }
@__cl_device_id__DefaultValue = internal constant i8* null
@__cl_event__Adapter = external constant i8*
@10 = internal constant %5 { i32 -2147483648, i32 35, i32 34, [35 x i8] c"KL: cl_event[] index out-of-bounds\00" }
@__cl_event_VA__Adapter = external constant i8*
@11 = internal constant %5 { i32 -2147483648, i32 35, i32 34, [35 x i8] c"KL: cl_event[] index out-of-bounds\00" }
@__cl_event__DefaultValue = internal constant i8* null
@__cl_kernel__Adapter = external constant i8*
@__cl_mem__Adapter = external constant i8*
@__cl_platform_id__Adapter = external constant i8*
@12 = internal constant %6 { i32 -2147483648, i32 41, i32 40, [41 x i8] c"KL: cl_platform_id[] index out-of-bounds\00" }
@__cl_platform_id_VA__Adapter = external constant i8*
@13 = internal constant %6 { i32 -2147483648, i32 41, i32 40, [41 x i8] c"KL: cl_platform_id[] index out-of-bounds\00" }
@__cl_platform_id__DefaultValue = internal constant i8* null
@__cl_program__Adapter = external constant i8*
@14 = internal constant %7 { i32 -2147483648, i32 2, i32 1, [2 x i8] c"#\00" }
@15 = internal constant %7 { i32 -2147483648, i32 2, i32 1, [2 x i8] c"*\00" }
@16 = internal constant %7 { i32 -2147483648, i32 2, i32 1, [2 x i8] c".\00" }
@17 = internal constant %7 { i32 -2147483648, i32 2, i32 1, [2 x i8] c" \00" }

define void @__construct_String__Boolean(%String* nocapture %stringLValue, i1 %booleanRValue) nounwind inlinehint {
entry:
  br i1 %booleanRValue, label %true, label %false

true:                                             ; preds = %entry
  %0 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%0* @0 to %String), i32 0, i32 0), i32 1)
  br label %merge

false:                                            ; preds = %entry
  %1 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%1* @1 to %String), i32 0, i32 0), i32 1)
  br label %merge

merge:                                            ; preds = %false, %true
  %stringRValue = phi %String [ bitcast (%0* @0 to %String), %true ], [ bitcast (%1* @1 to %String), %false ]
  %2 = load %String* %stringLValue
  store %String %stringRValue, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %merge
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  tail call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %merge, %nonNull.i, %free.i
  ret void
}

define void @__String__Retain(%String %string) nounwind inlinehint {
entry:
  %0 = icmp eq %String %string, null
  br i1 %0, label %done, label %addRef

addRef:                                           ; preds = %entry
  %1 = getelementptr %String %string, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %done

done:                                             ; preds = %entry, %addRef
  ret void
}

define void @__String__Release(%String %string) nounwind inlinehint {
entry:
  %0 = icmp eq %String %string, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %String %string, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %1, i32 1)
  %3 = icmp eq i32 %2, 1
  br i1 %3, label %free, label %done

free:                                             ; preds = %nonNull
  %4 = bitcast %String %string to i8*
  tail call void @free(i8* %4)
  br label %done

done:                                             ; preds = %entry, %free, %nonNull
  ret void
}

define i1 @__operator_BIT_NOT__Boolean(i1 %rValue) nounwind readnone inlinehint {
entry:
  %0 = xor i1 %rValue, true
  ret i1 %0
}

define i1 @__operator_BIT_OR__Boolean__Boolean(i1 %lhsRValue, i1 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = or i1 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_BIT_AND__Boolean__Boolean(i1 %lhsRValue, i1 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = and i1 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_BIT_XOR__Boolean__Boolean(i1 %lhsRValue, i1 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = xor i1 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_EQ__Boolean__Boolean(i1 %lhsRValue, i1 %rhsRValue) nounwind readnone inlinehint {
entry:
  %tmp = xor i1 %lhsRValue, %rhsRValue
  %0 = xor i1 %tmp, true
  ret i1 %0
}

define i1 @__operator_NE__Boolean__Boolean(i1 %lhsRValue, i1 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = xor i1 %lhsRValue, %rhsRValue
  ret i1 %0
}

define void @__construct_Boolean__Byte(i1* nocapture %booleanLValue, i8 %byteRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8 %byteRValue, 0
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_Integer__Byte(i32* nocapture %integerLValue, i8 %byteRValue) nounwind inlinehint {
entry:
  %0 = zext i8 %byteRValue to i32
  store i32 %0, i32* %integerLValue
  ret void
}

define void @__construct_Size__Byte(i32* nocapture %sizeLValue, i8 %byteRValue) nounwind inlinehint {
entry:
  %0 = zext i8 %byteRValue to i32
  store i32 %0, i32* %sizeLValue
  ret void
}

define void @__construct_Scalar__Byte(float* nocapture %scalarLValue, i8 %byteRValue) nounwind inlinehint {
entry:
  %0 = uitofp i8 %byteRValue to float
  store float %0, float* %scalarLValue
  ret void
}

define void @__construct_String__Byte(%String* nocapture %stringLValue, i8 %byteRValue) inlinehint {
entry:
  %byteRValue_tempLValue = alloca i8
  store i8 %byteRValue, i8* %byteRValue_tempLValue
  %0 = call %String @__String__Cast(i8* %byteRValue_tempLValue, i8* bitcast (i8** @__Byte__Adapter to i8*))
  %1 = load %String* %stringLValue
  store %String %0, %String* %stringLValue
  %2 = icmp eq %String %1, null
  br i1 %2, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %3 = getelementptr %String %1, i32 0, i32 0
  %4 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %3, i32 1)
  %5 = icmp eq i32 %4, 1
  br i1 %5, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %6 = bitcast %String %1 to i8*
  call void @free(i8* %6)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

declare %String @__String__Cast(i8*, i8*)

define i8 @__operator_POS__Byte(i8 %rValue) nounwind readnone inlinehint {
entry:
  ret i8 %rValue
}

define i8 @__operator_BIT_NOT__Byte(i8 %rValue) nounwind readnone inlinehint {
entry:
  %0 = xor i8 %rValue, -1
  ret i8 %0
}

define i8 @__operator_PRE_INC__Byte(i8* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i8* %lValue
  %1 = add i8 %0, 1
  store i8 %1, i8* %lValue
  ret i8 %1
}

define i8 @__operator_PRE_DEC__Byte(i8* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i8* %lValue
  %1 = add i8 %0, -1
  store i8 %1, i8* %lValue
  ret i8 %1
}

define i8 @__operator_POST_INC__Byte(i8* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i8* %lValue
  %1 = add i8 %0, 1
  store i8 %1, i8* %lValue
  ret i8 %0
}

define i8 @__operator_POST_DEC__Byte(i8* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i8* %lValue
  %1 = add i8 %0, -1
  store i8 %1, i8* %lValue
  ret i8 %0
}

define i8 @__operator_ADD__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = add i8 %rhsRValue, %lhsRValue
  ret i8 %0
}

define i8 @__operator_SUB__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = sub i8 %lhsRValue, %rhsRValue
  ret i8 %0
}

define i8 @__operator_MUL__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = mul i8 %rhsRValue, %lhsRValue
  ret i8 %0
}

define i8 @__operator_DIV__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind inlinehint {
entry:
  %0 = icmp eq i8 %rhsRValue, 0
  br i1 %0, label %zero, label %nonZero

nonZero:                                          ; preds = %entry
  %1 = udiv i8 %lhsRValue, %rhsRValue
  ret i8 %1

zero:                                             ; preds = %entry
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%2* @2 to %String), i32 0, i32 0), i32 1)
  %3 = load i32* getelementptr (%String bitcast (%2* @2 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%2* @2 to %String), i32 0, i32 3, i32 0), i32 %3)
  ret i8 0
}

define void @__String__Report(%String %string) nounwind inlinehint {
entry:
  %0 = icmp eq %String %string, null
  br i1 %0, label %done, label %notNull

notNull:                                          ; preds = %entry
  %1 = getelementptr %String %string, i32 0, i32 3, i32 0
  %2 = getelementptr %String %string, i32 0, i32 2
  %3 = load i32* %2
  tail call void @report(i8* %1, i32 %3)
  br label %done

done:                                             ; preds = %entry, %notNull
  ret void
}

define i8 @__operator_MOD__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind inlinehint {
entry:
  %0 = icmp eq i8 %rhsRValue, 0
  br i1 %0, label %zero, label %nonZero

nonZero:                                          ; preds = %entry
  %1 = urem i8 %lhsRValue, %rhsRValue
  ret i8 %1

zero:                                             ; preds = %entry
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%2* @3 to %String), i32 0, i32 0), i32 1)
  %3 = load i32* getelementptr (%String bitcast (%2* @3 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%2* @3 to %String), i32 0, i32 3, i32 0), i32 %3)
  ret i8 0
}

define i8 @__operator_BIT_OR__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = or i8 %rhsRValue, %lhsRValue
  ret i8 %0
}

define i8 @__operator_BIT_AND__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = and i8 %rhsRValue, %lhsRValue
  ret i8 %0
}

define i8 @__operator_BIT_XOR__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = xor i8 %rhsRValue, %lhsRValue
  ret i8 %0
}

define i1 @__operator_EQ__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq i8 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_NE__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ne i8 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GT__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ugt i8 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GE__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp uge i8 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LT__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ult i8 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LE__Byte__Byte(i8 %lhsRValue, i8 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ule i8 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i32 @__method_dataSize__Byte(i8 %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 1
}

define i8* @__method_data__Byte(i8* nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  ret i8* %selfLValue
}

define void @__construct_Boolean__Data(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__Data(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__Data__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__Data(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__Data(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__Integer(i1* nocapture %booleanLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i32 %integerRValue, 0
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_Byte__Integer(i8* nocapture %byteLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  %0 = trunc i32 %integerRValue to i8
  store i8 %0, i8* %byteLValue
  ret void
}

define void @__construct_Size__Integer(i32* nocapture %sizeLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  store i32 %integerRValue, i32* %sizeLValue
  ret void
}

define void @__construct_Scalar__Integer(float* nocapture %scalarLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  %0 = sitofp i32 %integerRValue to float
  store float %0, float* %scalarLValue
  ret void
}

define void @__construct_String__Integer(%String* nocapture %stringLValue, i32 %integerRValue) inlinehint {
entry:
  %integerRValue_tempLValue = alloca i32
  store i32 %integerRValue, i32* %integerRValue_tempLValue
  %0 = bitcast i32* %integerRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__Integer__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__operator_POS__Integer(i32 %rValue) nounwind readnone inlinehint {
entry:
  ret i32 %rValue
}

define i32 @__operator_NEG__Integer(i32 %rValue) nounwind readnone inlinehint {
entry:
  %0 = sub i32 0, %rValue
  ret i32 %0
}

define i32 @__operator_BIT_NOT__Integer(i32 %rValue) nounwind readnone inlinehint {
entry:
  %0 = xor i32 %rValue, -1
  ret i32 %0
}

define i32 @__operator_PRE_INC__Integer(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, 1
  store i32 %1, i32* %lValue
  ret i32 %1
}

define i32 @__operator_PRE_DEC__Integer(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, -1
  store i32 %1, i32* %lValue
  ret i32 %1
}

define i32 @__operator_POST_INC__Integer(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, 1
  store i32 %1, i32* %lValue
  ret i32 %0
}

define i32 @__operator_POST_DEC__Integer(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, -1
  store i32 %1, i32* %lValue
  ret i32 %0
}

define i32 @__operator_ADD__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = add i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_SUB__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = sub i32 %lhsRValue, %rhsRValue
  ret i32 %0
}

define i32 @__operator_MUL__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = mul i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_DIV__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind inlinehint {
entry:
  %0 = icmp eq i32 %rhsRValue, 0
  br i1 %0, label %zero, label %nonZero

nonZero:                                          ; preds = %entry
  %1 = sdiv i32 %lhsRValue, %rhsRValue
  ret i32 %1

zero:                                             ; preds = %entry
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%3* @4 to %String), i32 0, i32 0), i32 1)
  %3 = load i32* getelementptr (%String bitcast (%3* @4 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%3* @4 to %String), i32 0, i32 3, i32 0), i32 %3)
  ret i32 0
}

define i32 @__operator_MOD__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind inlinehint {
entry:
  %0 = icmp eq i32 %rhsRValue, 0
  br i1 %0, label %zero, label %nonZero

nonZero:                                          ; preds = %entry
  %1 = srem i32 %lhsRValue, %rhsRValue
  ret i32 %1

zero:                                             ; preds = %entry
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%3* @5 to %String), i32 0, i32 0), i32 1)
  %3 = load i32* getelementptr (%String bitcast (%3* @5 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%3* @5 to %String), i32 0, i32 3, i32 0), i32 %3)
  ret i32 0
}

define i32 @__operator_BIT_OR__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = or i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_BIT_AND__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = and i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_BIT_XOR__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = xor i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i1 @__operator_EQ__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_NE__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ne i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GT__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp sgt i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GE__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp sge i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LT__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp slt i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LE__Integer__Integer(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp sle i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i32 @__method_dataSize__Integer(i32 %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__Integer(i32* nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i32* %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__Scalar(i1* nocapture %booleanLValue, float %scalarRValue) nounwind inlinehint {
entry:
  %0 = fcmp one float %scalarRValue, 0.000000e+00
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_Byte__Scalar(i8* nocapture %byteLValue, float %scalarRValue) nounwind inlinehint {
entry:
  %0 = fptoui float %scalarRValue to i8
  store i8 %0, i8* %byteLValue
  ret void
}

define void @__construct_Integer__Scalar(i32* nocapture %integerLValue, float %scalarRValue) nounwind inlinehint {
entry:
  %0 = fptosi float %scalarRValue to i32
  store i32 %0, i32* %integerLValue
  ret void
}

define void @__construct_Size__Scalar(i32* nocapture %sizeLValue, float %scalarRValue) nounwind inlinehint {
entry:
  %0 = fptoui float %scalarRValue to i32
  store i32 %0, i32* %sizeLValue
  ret void
}

define void @__construct_String__Scalar(%String* nocapture %stringLValue, float %scalarRValue) inlinehint {
entry:
  %scalarRValue_tempLValue = alloca float
  store float %scalarRValue, float* %scalarRValue_tempLValue
  %0 = bitcast float* %scalarRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__Scalar__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define float @__operator_POS__Scalar(float %rValue) nounwind readnone inlinehint {
entry:
  ret float %rValue
}

define float @__operator_NEG__Scalar(float %rValue) nounwind readnone inlinehint {
entry:
  %0 = fsub float -0.000000e+00, %rValue
  ret float %0
}

define float @sin(float %x) nounwind readonly inlinehint {
entry:
  %0 = tail call float @llvm.sin.f32(float %x)
  ret float %0
}

declare float @llvm.sin.f32(float) nounwind readonly

define float @cos(float %x) nounwind readonly inlinehint {
entry:
  %0 = tail call float @llvm.cos.f32(float %x)
  ret float %0
}

declare float @llvm.cos.f32(float) nounwind readonly

declare float @tanf(float) inlinehint

define float @tan(float %x) inlinehint {
entry:
  %0 = tail call float @tanf(float %x)
  ret float %0
}

declare float @logf(float) inlinehint

define float @log(float %x) inlinehint {
entry:
  %0 = tail call float @logf(float %x)
  ret float %0
}

declare float @acosf(float) inlinehint

define float @acos(float %x) inlinehint {
entry:
  %0 = tail call float @acosf(float %x)
  ret float %0
}

declare float @asinf(float) inlinehint

define float @asin(float %x) inlinehint {
entry:
  %0 = tail call float @asinf(float %x)
  ret float %0
}

declare float @atanf(float) inlinehint

define float @atan(float %x) inlinehint {
entry:
  %0 = tail call float @atanf(float %x)
  ret float %0
}

declare float @atan2f(float, float) inlinehint

define float @atan2(float %y, float %x) inlinehint {
entry:
  %0 = tail call float @atan2f(float %y, float %x)
  ret float %0
}

define float @sqrt(float %x) nounwind readonly inlinehint {
entry:
  %0 = tail call float @llvm.sqrt.f32(float %x)
  ret float %0
}

declare float @llvm.sqrt.f32(float) nounwind readonly

define float @abs(float %x) nounwind readnone inlinehint {
entry:
  %0 = bitcast float %x to i32
  %1 = and i32 %0, 2147483647
  %2 = bitcast i32 %1 to float
  ret float %2
}

declare float @roundf(float) inlinehint

define float @round(float %x) inlinehint {
entry:
  %0 = tail call float @roundf(float %x)
  ret float %0
}

declare float @ceilf(float) inlinehint

define float @ceil(float %x) inlinehint {
entry:
  %0 = tail call float @ceilf(float %x)
  ret float %0
}

declare float @floorf(float) inlinehint

define float @floor(float %x) inlinehint {
entry:
  %0 = tail call float @floorf(float %x)
  ret float %0
}

define float @pow(float %x, float %y) nounwind readonly inlinehint {
entry:
  %0 = tail call float @llvm.pow.f32(float %x, float %y)
  ret float %0
}

declare float @llvm.pow.f32(float, float) nounwind readonly

define float @__operator_ADD__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fadd float %lhsRValue, %rhsRValue
  ret float %0
}

define float @__operator_SUB__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fsub float %lhsRValue, %rhsRValue
  ret float %0
}

define float @__operator_MUL__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fmul float %lhsRValue, %rhsRValue
  ret float %0
}

define float @__operator_DIV__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fdiv float %lhsRValue, %rhsRValue
  ret float %0
}

define float @__operator_MOD__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = frem float %lhsRValue, %rhsRValue
  ret float %0
}

define i1 @__operator_EQ__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fcmp oeq float %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_NE__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fcmp one float %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GT__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fcmp ogt float %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GE__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fcmp oge float %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LT__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fcmp olt float %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LE__Scalar__Scalar(float %lhsRValue, float %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = fcmp ole float %lhsRValue, %rhsRValue
  ret i1 %0
}

define i32 @__method_dataSize__Scalar(float %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__Scalar(float* nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast float* %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__Size(i1* nocapture %booleanLValue, i32 %sizeRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i32 %sizeRValue, 0
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_Byte__Size(i8* nocapture %byteLValue, i32 %sizeRValue) nounwind inlinehint {
entry:
  %0 = trunc i32 %sizeRValue to i8
  store i8 %0, i8* %byteLValue
  ret void
}

define void @__construct_Integer__Size(i32* nocapture %integerLValue, i32 %sizeRValue) nounwind inlinehint {
entry:
  store i32 %sizeRValue, i32* %integerLValue
  ret void
}

define void @__construct_Scalar__Size(float* nocapture %scalarLValue, i32 %sizeRValue) nounwind inlinehint {
entry:
  %0 = uitofp i32 %sizeRValue to float
  store float %0, float* %scalarLValue
  ret void
}

define void @__construct_String__Size(%String* nocapture %stringLValue, i32 %sizeRValue) inlinehint {
entry:
  %sizeRValue_tempLValue = alloca i32
  store i32 %sizeRValue, i32* %sizeRValue_tempLValue
  %0 = bitcast i32* %sizeRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__Size__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__operator_POS__Size(i32 %rValue) nounwind readnone inlinehint {
entry:
  ret i32 %rValue
}

define i32 @__operator_BIT_NOT__Size(i32 %rValue) nounwind readnone inlinehint {
entry:
  %0 = xor i32 %rValue, -1
  ret i32 %0
}

define i32 @__operator_PRE_INC__Size(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, 1
  store i32 %1, i32* %lValue
  ret i32 %1
}

define i32 @__operator_PRE_DEC__Size(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, -1
  store i32 %1, i32* %lValue
  ret i32 %1
}

define i32 @__operator_POST_INC__Size(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, 1
  store i32 %1, i32* %lValue
  ret i32 %0
}

define i32 @__operator_POST_DEC__Size(i32* nocapture %lValue) nounwind inlinehint {
entry:
  %0 = load i32* %lValue
  %1 = add i32 %0, -1
  store i32 %1, i32* %lValue
  ret i32 %0
}

define i32 @__operator_ADD__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = add i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_SUB__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = sub i32 %lhsRValue, %rhsRValue
  ret i32 %0
}

define i32 @__operator_MUL__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = mul i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_DIV__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind inlinehint {
entry:
  %0 = icmp eq i32 %rhsRValue, 0
  br i1 %0, label %zero, label %nonZero

nonZero:                                          ; preds = %entry
  %1 = udiv i32 %lhsRValue, %rhsRValue
  ret i32 %1

zero:                                             ; preds = %entry
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%2* @6 to %String), i32 0, i32 0), i32 1)
  %3 = load i32* getelementptr (%String bitcast (%2* @6 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%2* @6 to %String), i32 0, i32 3, i32 0), i32 %3)
  ret i32 0
}

define i32 @__operator_MOD__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind inlinehint {
entry:
  %0 = icmp eq i32 %rhsRValue, 0
  br i1 %0, label %zero, label %nonZero

nonZero:                                          ; preds = %entry
  %1 = urem i32 %lhsRValue, %rhsRValue
  ret i32 %1

zero:                                             ; preds = %entry
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%2* @7 to %String), i32 0, i32 0), i32 1)
  %3 = load i32* getelementptr (%String bitcast (%2* @7 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%2* @7 to %String), i32 0, i32 3, i32 0), i32 %3)
  ret i32 0
}

define i32 @__operator_BIT_OR__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = or i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_BIT_AND__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = and i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i32 @__operator_BIT_XOR__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = xor i32 %rhsRValue, %lhsRValue
  ret i32 %0
}

define i1 @__operator_EQ__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_NE__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ne i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GT__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ugt i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_GE__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp uge i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LT__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ult i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i1 @__operator_LE__Size__Size(i32 %lhsRValue, i32 %rhsRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp ule i32 %lhsRValue, %rhsRValue
  ret i1 %0
}

define i32 @__method_dataSize__Size(i32 %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__Size(i32* nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i32* %selfLValue to i8*
  ret i8* %0
}

declare void @report(i8*, i32) nounwind inlinehint

declare i32 @llvm.atomic.load.add.i32.p0i32(i32* nocapture, i32) nounwind

declare i32 @llvm.atomic.load.sub.i32.p0i32(i32* nocapture, i32) nounwind

declare void @free(i8* nocapture) nounwind

define i32 @__String__Length(%String %string) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %string, null
  br i1 %0, label %null, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %String %string, i32 0, i32 2
  %2 = load i32* %1
  ret i32 %2

null:                                             ; preds = %entry
  ret i32 0
}

define void @__construct_Boolean__String(i1* nocapture %booleanLValue, %String %stringRValue) nounwind inlinehint {
entry:
  %0 = icmp eq %String %stringRValue, null
  br i1 %0, label %__String__Length.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %String %stringRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = icmp ne i32 %2, 0
  br label %__String__Length.exit

__String__Length.exit:                            ; preds = %entry, %nonNull.i
  %3 = phi i1 [ %phitmp, %nonNull.i ], [ false, %entry ]
  store i1 %3, i1* %booleanLValue
  ret void
}

declare void @__String__Append(%String*, %String)

define void @__method_ASSIGN_OP_ADD__String__String(%String* nocapture %lhsLValue, %String %rhsRValue) inlinehint {
entry:
  tail call void @__String__Append(%String* %lhsLValue, %String %rhsRValue)
  ret void
}

define %String @__operator_ADD__String__String(%String %lhsRValue, %String %rhsRValue) inlinehint {
entry:
  %result = alloca %String
  store %String null, %String* %result
  %0 = icmp eq %String %lhsRValue, null
  br i1 %0, label %__String__Release.exit, label %__String__Retain.exit

__String__Retain.exit:                            ; preds = %entry
  %1 = getelementptr %String %lhsRValue, i32 0, i32 0
  %2 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %__String__Retain.exit
  store %String %lhsRValue, %String* %result
  call void @__String__Append(%String* %result, %String %rhsRValue)
  %3 = load %String* %result
  ret %String %3
}

define i32 @__method_length__String(%String %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %selfRValue, null
  br i1 %0, label %__String__Length.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %String %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  br label %__String__Length.exit

__String__Length.exit:                            ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %2, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i32 @__method_dataSize__String(%String %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %selfRValue, null
  br i1 %0, label %__String__Length.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %String %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = add i32 %2, 1
  br label %__String__Length.exit

__String__Length.exit:                            ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %phitmp, %nonNull.i ], [ 1, %entry ]
  ret i32 %3
}

define i8* @__method_data__String(%String %selfRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq %String %selfRValue, null
  br i1 %0, label %null, label %nonNull

null:                                             ; preds = %entry
  %1 = bitcast %String %selfRValue to i8*
  ret i8* %1

nonNull:                                          ; preds = %entry
  %2 = getelementptr %String %selfRValue, i32 0, i32 3, i32 0
  ret i8* %2
}

define i32 @__method_compare__String__String(%String %lhs, %String %rhs) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhs, null
  %1 = icmp eq %String %rhs, null
  br i1 %0, label %selfIsNull, label %selfIsNotNull

selfIsNull:                                       ; preds = %entry
  br i1 %1, label %eq, label %lt

selfIsNotNull:                                    ; preds = %entry
  br i1 %1, label %eq, label %shallow

shallow:                                          ; preds = %selfIsNotNull
  %2 = icmp eq %String %lhs, %rhs
  br i1 %2, label %eq, label %deep

deep:                                             ; preds = %shallow
  %selfLengthPtr = getelementptr inbounds %String %lhs, i32 0, i32 2
  %selfLength = load i32* %selfLengthPtr
  %otherLengthPtr = getelementptr inbounds %String %rhs, i32 0, i32 2
  %otherLength = load i32* %otherLengthPtr
  br label %check

check:                                            ; preds = %next, %deep
  %3 = phi i32 [ 0, %deep ], [ %8, %next ]
  %4 = icmp ult i32 %3, %selfLength
  %5 = icmp ult i32 %3, %otherLength
  br i1 %4, label %checkOtherLength, label %verifyOtherLength

verifyOtherLength:                                ; preds = %check
  br i1 %5, label %lt, label %eq

checkOtherLength:                                 ; preds = %check
  br i1 %5, label %checkChars, label %eq

checkChars:                                       ; preds = %checkOtherLength
  %selfCharPtr = getelementptr %String %lhs, i32 0, i32 3, i32 %3
  %selfChar = load i8* %selfCharPtr
  %otherCharPtr = getelementptr %String %rhs, i32 0, i32 3, i32 %3
  %otherChar = load i8* %otherCharPtr
  %6 = icmp ult i8 %selfChar, %otherChar
  br i1 %6, label %lt, label %checkCharsGT

checkCharsGT:                                     ; preds = %checkChars
  %7 = icmp ugt i8 %selfChar, %otherChar
  br i1 %7, label %eq, label %next

next:                                             ; preds = %checkCharsGT
  %8 = add i32 %3, 1
  br label %check

eq:                                               ; preds = %checkOtherLength, %checkCharsGT, %selfIsNotNull, %lt, %verifyOtherLength, %shallow, %selfIsNull
  %merge = phi i32 [ 0, %verifyOtherLength ], [ 0, %shallow ], [ 0, %selfIsNull ], [ -1, %lt ], [ 1, %selfIsNotNull ], [ 1, %checkCharsGT ], [ 1, %checkOtherLength ]
  ret i32 %merge

lt:                                               ; preds = %checkChars, %verifyOtherLength, %selfIsNull
  br label %eq
}

define i1 @__operator_EQ__String__String(%String %lhsRValue, %String %rhsRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhsRValue, null
  %1 = icmp eq %String %rhsRValue, null
  br i1 %0, label %selfIsNull.i, label %selfIsNotNull.i

selfIsNull.i:                                     ; preds = %entry
  br i1 %1, label %__method_compare__String__String.exit, label %lt.i

selfIsNotNull.i:                                  ; preds = %entry
  br i1 %1, label %__method_compare__String__String.exit, label %shallow.i

shallow.i:                                        ; preds = %selfIsNotNull.i
  %2 = icmp eq %String %lhsRValue, %rhsRValue
  br i1 %2, label %__method_compare__String__String.exit, label %deep.i

deep.i:                                           ; preds = %shallow.i
  %selfLengthPtr.i = getelementptr inbounds %String %lhsRValue, i32 0, i32 2
  %selfLength.i = load i32* %selfLengthPtr.i
  %otherLengthPtr.i = getelementptr inbounds %String %rhsRValue, i32 0, i32 2
  %otherLength.i = load i32* %otherLengthPtr.i
  br label %check.i

check.i:                                          ; preds = %next.i, %deep.i
  %3 = phi i32 [ 0, %deep.i ], [ %8, %next.i ]
  %4 = icmp ult i32 %3, %selfLength.i
  %5 = icmp ult i32 %3, %otherLength.i
  br i1 %4, label %checkOtherLength.i, label %verifyOtherLength.i

verifyOtherLength.i:                              ; preds = %check.i
  br i1 %5, label %lt.i, label %__method_compare__String__String.exit

checkOtherLength.i:                               ; preds = %check.i
  br i1 %5, label %checkChars.i, label %__method_compare__String__String.exit

checkChars.i:                                     ; preds = %checkOtherLength.i
  %selfCharPtr.i = getelementptr %String %lhsRValue, i32 0, i32 3, i32 %3
  %selfChar.i = load i8* %selfCharPtr.i
  %otherCharPtr.i = getelementptr %String %rhsRValue, i32 0, i32 3, i32 %3
  %otherChar.i = load i8* %otherCharPtr.i
  %6 = icmp ult i8 %selfChar.i, %otherChar.i
  br i1 %6, label %lt.i, label %checkCharsGT.i

checkCharsGT.i:                                   ; preds = %checkChars.i
  %7 = icmp ugt i8 %selfChar.i, %otherChar.i
  br i1 %7, label %__method_compare__String__String.exit, label %next.i

next.i:                                           ; preds = %checkCharsGT.i
  %8 = add i32 %3, 1
  br label %check.i

lt.i:                                             ; preds = %checkChars.i, %verifyOtherLength.i, %selfIsNull.i
  br label %__method_compare__String__String.exit

__method_compare__String__String.exit:            ; preds = %checkOtherLength.i, %checkCharsGT.i, %selfIsNull.i, %selfIsNotNull.i, %shallow.i, %verifyOtherLength.i, %lt.i
  %merge.i = phi i1 [ true, %verifyOtherLength.i ], [ true, %shallow.i ], [ true, %selfIsNull.i ], [ false, %lt.i ], [ false, %selfIsNotNull.i ], [ false, %checkCharsGT.i ], [ false, %checkOtherLength.i ]
  ret i1 %merge.i
}

define i1 @__operator_NE__String__String(%String %lhsRValue, %String %rhsRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhsRValue, null
  %1 = icmp eq %String %rhsRValue, null
  br i1 %0, label %selfIsNull.i, label %selfIsNotNull.i

selfIsNull.i:                                     ; preds = %entry
  br i1 %1, label %__method_compare__String__String.exit, label %lt.i

selfIsNotNull.i:                                  ; preds = %entry
  br i1 %1, label %__method_compare__String__String.exit, label %shallow.i

shallow.i:                                        ; preds = %selfIsNotNull.i
  %2 = icmp eq %String %lhsRValue, %rhsRValue
  br i1 %2, label %__method_compare__String__String.exit, label %deep.i

deep.i:                                           ; preds = %shallow.i
  %selfLengthPtr.i = getelementptr inbounds %String %lhsRValue, i32 0, i32 2
  %selfLength.i = load i32* %selfLengthPtr.i
  %otherLengthPtr.i = getelementptr inbounds %String %rhsRValue, i32 0, i32 2
  %otherLength.i = load i32* %otherLengthPtr.i
  br label %check.i

check.i:                                          ; preds = %next.i, %deep.i
  %3 = phi i32 [ 0, %deep.i ], [ %8, %next.i ]
  %4 = icmp ult i32 %3, %selfLength.i
  %5 = icmp ult i32 %3, %otherLength.i
  br i1 %4, label %checkOtherLength.i, label %verifyOtherLength.i

verifyOtherLength.i:                              ; preds = %check.i
  br i1 %5, label %lt.i, label %__method_compare__String__String.exit

checkOtherLength.i:                               ; preds = %check.i
  br i1 %5, label %checkChars.i, label %__method_compare__String__String.exit

checkChars.i:                                     ; preds = %checkOtherLength.i
  %selfCharPtr.i = getelementptr %String %lhsRValue, i32 0, i32 3, i32 %3
  %selfChar.i = load i8* %selfCharPtr.i
  %otherCharPtr.i = getelementptr %String %rhsRValue, i32 0, i32 3, i32 %3
  %otherChar.i = load i8* %otherCharPtr.i
  %6 = icmp ult i8 %selfChar.i, %otherChar.i
  br i1 %6, label %lt.i, label %checkCharsGT.i

checkCharsGT.i:                                   ; preds = %checkChars.i
  %7 = icmp ugt i8 %selfChar.i, %otherChar.i
  br i1 %7, label %__method_compare__String__String.exit, label %next.i

next.i:                                           ; preds = %checkCharsGT.i
  %8 = add i32 %3, 1
  br label %check.i

lt.i:                                             ; preds = %checkChars.i, %verifyOtherLength.i, %selfIsNull.i
  br label %__method_compare__String__String.exit

__method_compare__String__String.exit:            ; preds = %checkOtherLength.i, %checkCharsGT.i, %selfIsNull.i, %selfIsNotNull.i, %shallow.i, %verifyOtherLength.i, %lt.i
  %merge.i = phi i1 [ false, %verifyOtherLength.i ], [ false, %shallow.i ], [ false, %selfIsNull.i ], [ true, %lt.i ], [ true, %selfIsNotNull.i ], [ true, %checkCharsGT.i ], [ true, %checkOtherLength.i ]
  ret i1 %merge.i
}

define i1 @__operator_GT__String__String(%String %lhsRValue, %String %rhsRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhsRValue, null
  %1 = icmp eq %String %rhsRValue, null
  %brmerge = or i1 %0, %1
  %not. = xor i1 %0, true
  br i1 %brmerge, label %verifyOtherLength.i, label %shallow.i

shallow.i:                                        ; preds = %entry
  %2 = icmp eq %String %lhsRValue, %rhsRValue
  br i1 %2, label %verifyOtherLength.i, label %deep.i

deep.i:                                           ; preds = %shallow.i
  %selfLengthPtr.i = getelementptr inbounds %String %lhsRValue, i32 0, i32 2
  %selfLength.i = load i32* %selfLengthPtr.i
  %otherLengthPtr.i = getelementptr inbounds %String %rhsRValue, i32 0, i32 2
  %otherLength.i = load i32* %otherLengthPtr.i
  br label %check.i

check.i:                                          ; preds = %next.i, %deep.i
  %3 = phi i32 [ 0, %deep.i ], [ %8, %next.i ]
  %4 = icmp ult i32 %3, %selfLength.i
  br i1 %4, label %checkOtherLength.i, label %verifyOtherLength.i

verifyOtherLength.i:                              ; preds = %checkCharsGT.i, %checkOtherLength.i, %checkChars.i, %check.i, %shallow.i, %entry
  %merge = phi i1 [ false, %shallow.i ], [ %not., %entry ], [ true, %checkCharsGT.i ], [ true, %checkOtherLength.i ], [ false, %checkChars.i ], [ false, %check.i ]
  ret i1 %merge

checkOtherLength.i:                               ; preds = %check.i
  %5 = icmp ult i32 %3, %otherLength.i
  br i1 %5, label %checkChars.i, label %verifyOtherLength.i

checkChars.i:                                     ; preds = %checkOtherLength.i
  %selfCharPtr.i = getelementptr %String %lhsRValue, i32 0, i32 3, i32 %3
  %selfChar.i = load i8* %selfCharPtr.i
  %otherCharPtr.i = getelementptr %String %rhsRValue, i32 0, i32 3, i32 %3
  %otherChar.i = load i8* %otherCharPtr.i
  %6 = icmp ult i8 %selfChar.i, %otherChar.i
  br i1 %6, label %verifyOtherLength.i, label %checkCharsGT.i

checkCharsGT.i:                                   ; preds = %checkChars.i
  %7 = icmp ugt i8 %selfChar.i, %otherChar.i
  br i1 %7, label %verifyOtherLength.i, label %next.i

next.i:                                           ; preds = %checkCharsGT.i
  %8 = add i32 %3, 1
  br label %check.i
}

define i1 @__operator_GE__String__String(%String %lhsRValue, %String %rhsRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhsRValue, null
  %1 = icmp eq %String %rhsRValue, null
  br i1 %0, label %selfIsNull.i, label %selfIsNotNull.i

selfIsNull.i:                                     ; preds = %entry
  br i1 %1, label %__method_compare__String__String.exit, label %lt.i

selfIsNotNull.i:                                  ; preds = %entry
  %2 = icmp eq %String %lhsRValue, %rhsRValue
  %or.cond = or i1 %1, %2
  br i1 %or.cond, label %__method_compare__String__String.exit, label %deep.i

deep.i:                                           ; preds = %selfIsNotNull.i
  %selfLengthPtr.i = getelementptr inbounds %String %lhsRValue, i32 0, i32 2
  %selfLength.i = load i32* %selfLengthPtr.i
  %otherLengthPtr.i = getelementptr inbounds %String %rhsRValue, i32 0, i32 2
  %otherLength.i = load i32* %otherLengthPtr.i
  br label %check.i

check.i:                                          ; preds = %next.i, %deep.i
  %3 = phi i32 [ 0, %deep.i ], [ %8, %next.i ]
  %4 = icmp ult i32 %3, %selfLength.i
  %5 = icmp ult i32 %3, %otherLength.i
  br i1 %4, label %checkOtherLength.i, label %verifyOtherLength.i

verifyOtherLength.i:                              ; preds = %check.i
  br i1 %5, label %lt.i, label %__method_compare__String__String.exit

checkOtherLength.i:                               ; preds = %check.i
  br i1 %5, label %checkChars.i, label %__method_compare__String__String.exit

checkChars.i:                                     ; preds = %checkOtherLength.i
  %selfCharPtr.i = getelementptr %String %lhsRValue, i32 0, i32 3, i32 %3
  %selfChar.i = load i8* %selfCharPtr.i
  %otherCharPtr.i = getelementptr %String %rhsRValue, i32 0, i32 3, i32 %3
  %otherChar.i = load i8* %otherCharPtr.i
  %6 = icmp ult i8 %selfChar.i, %otherChar.i
  br i1 %6, label %lt.i, label %checkCharsGT.i

checkCharsGT.i:                                   ; preds = %checkChars.i
  %7 = icmp ugt i8 %selfChar.i, %otherChar.i
  br i1 %7, label %__method_compare__String__String.exit, label %next.i

next.i:                                           ; preds = %checkCharsGT.i
  %8 = add i32 %3, 1
  br label %check.i

lt.i:                                             ; preds = %checkChars.i, %verifyOtherLength.i, %selfIsNull.i
  br label %__method_compare__String__String.exit

__method_compare__String__String.exit:            ; preds = %checkOtherLength.i, %checkCharsGT.i, %selfIsNull.i, %selfIsNotNull.i, %verifyOtherLength.i, %lt.i
  %merge.i = phi i1 [ true, %verifyOtherLength.i ], [ true, %selfIsNull.i ], [ false, %lt.i ], [ true, %selfIsNotNull.i ], [ true, %checkCharsGT.i ], [ true, %checkOtherLength.i ]
  ret i1 %merge.i
}

define i1 @__operator_LT__String__String(%String %lhsRValue, %String %rhsRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhsRValue, null
  %1 = icmp eq %String %rhsRValue, null
  br i1 %0, label %selfIsNull.i, label %selfIsNotNull.i

selfIsNull.i:                                     ; preds = %entry
  br i1 %1, label %__method_compare__String__String.exit, label %lt.i

selfIsNotNull.i:                                  ; preds = %entry
  %2 = icmp eq %String %lhsRValue, %rhsRValue
  %or.cond = or i1 %1, %2
  br i1 %or.cond, label %__method_compare__String__String.exit, label %deep.i

deep.i:                                           ; preds = %selfIsNotNull.i
  %selfLengthPtr.i = getelementptr inbounds %String %lhsRValue, i32 0, i32 2
  %selfLength.i = load i32* %selfLengthPtr.i
  %otherLengthPtr.i = getelementptr inbounds %String %rhsRValue, i32 0, i32 2
  %otherLength.i = load i32* %otherLengthPtr.i
  br label %check.i

check.i:                                          ; preds = %next.i, %deep.i
  %3 = phi i32 [ 0, %deep.i ], [ %8, %next.i ]
  %4 = icmp ult i32 %3, %selfLength.i
  %5 = icmp ult i32 %3, %otherLength.i
  br i1 %4, label %checkOtherLength.i, label %verifyOtherLength.i

verifyOtherLength.i:                              ; preds = %check.i
  br i1 %5, label %lt.i, label %__method_compare__String__String.exit

checkOtherLength.i:                               ; preds = %check.i
  br i1 %5, label %checkChars.i, label %__method_compare__String__String.exit

checkChars.i:                                     ; preds = %checkOtherLength.i
  %selfCharPtr.i = getelementptr %String %lhsRValue, i32 0, i32 3, i32 %3
  %selfChar.i = load i8* %selfCharPtr.i
  %otherCharPtr.i = getelementptr %String %rhsRValue, i32 0, i32 3, i32 %3
  %otherChar.i = load i8* %otherCharPtr.i
  %6 = icmp ult i8 %selfChar.i, %otherChar.i
  br i1 %6, label %lt.i, label %checkCharsGT.i

checkCharsGT.i:                                   ; preds = %checkChars.i
  %7 = icmp ugt i8 %selfChar.i, %otherChar.i
  br i1 %7, label %__method_compare__String__String.exit, label %next.i

next.i:                                           ; preds = %checkCharsGT.i
  %8 = add i32 %3, 1
  br label %check.i

lt.i:                                             ; preds = %checkChars.i, %verifyOtherLength.i, %selfIsNull.i
  br label %__method_compare__String__String.exit

__method_compare__String__String.exit:            ; preds = %checkOtherLength.i, %checkCharsGT.i, %selfIsNull.i, %selfIsNotNull.i, %verifyOtherLength.i, %lt.i
  %merge.i = phi i1 [ false, %verifyOtherLength.i ], [ false, %selfIsNull.i ], [ true, %lt.i ], [ false, %selfIsNotNull.i ], [ false, %checkCharsGT.i ], [ false, %checkOtherLength.i ]
  ret i1 %merge.i
}

define i1 @__operator_LE__String__String(%String %lhsRValue, %String %rhsRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %String %lhsRValue, null
  %1 = icmp eq %String %rhsRValue, null
  %brmerge = or i1 %0, %1
  br i1 %brmerge, label %verifyOtherLength.i, label %shallow.i

shallow.i:                                        ; preds = %entry
  %2 = icmp eq %String %lhsRValue, %rhsRValue
  br i1 %2, label %verifyOtherLength.i, label %deep.i

deep.i:                                           ; preds = %shallow.i
  %selfLengthPtr.i = getelementptr inbounds %String %lhsRValue, i32 0, i32 2
  %selfLength.i = load i32* %selfLengthPtr.i
  %otherLengthPtr.i = getelementptr inbounds %String %rhsRValue, i32 0, i32 2
  %otherLength.i = load i32* %otherLengthPtr.i
  br label %check.i

check.i:                                          ; preds = %next.i, %deep.i
  %3 = phi i32 [ 0, %deep.i ], [ %8, %next.i ]
  %4 = icmp ult i32 %3, %selfLength.i
  br i1 %4, label %checkOtherLength.i, label %verifyOtherLength.i

verifyOtherLength.i:                              ; preds = %checkCharsGT.i, %checkOtherLength.i, %checkChars.i, %check.i, %shallow.i, %entry
  %merge = phi i1 [ true, %shallow.i ], [ %0, %entry ], [ false, %checkCharsGT.i ], [ false, %checkOtherLength.i ], [ true, %checkChars.i ], [ true, %check.i ]
  ret i1 %merge

checkOtherLength.i:                               ; preds = %check.i
  %5 = icmp ult i32 %3, %otherLength.i
  br i1 %5, label %checkChars.i, label %verifyOtherLength.i

checkChars.i:                                     ; preds = %checkOtherLength.i
  %selfCharPtr.i = getelementptr %String %lhsRValue, i32 0, i32 3, i32 %3
  %selfChar.i = load i8* %selfCharPtr.i
  %otherCharPtr.i = getelementptr %String %rhsRValue, i32 0, i32 3, i32 %3
  %otherChar.i = load i8* %otherCharPtr.i
  %6 = icmp ult i8 %selfChar.i, %otherChar.i
  br i1 %6, label %verifyOtherLength.i, label %checkCharsGT.i

checkCharsGT.i:                                   ; preds = %checkChars.i
  %7 = icmp ugt i8 %selfChar.i, %otherChar.i
  br i1 %7, label %verifyOtherLength.i, label %next.i

next.i:                                           ; preds = %checkCharsGT.i
  %8 = add i32 %3, 1
  br label %check.i
}

define void @__construct_Boolean__cl_command_queue(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_command_queue(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_command_queue__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_command_queue(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_command_queue(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__cl_context(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_context(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_context__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_context(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_context(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__cl_device_id(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_device_id(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_device_id__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_device_id(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_device_id(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__cl_device_id_VA__Retain(%cl_device_id_VA %array) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %done

done:                                             ; preds = %entry, %nonNull
  ret void
}

define void @__cl_device_id_VA__Release(%cl_device_id_VA %array) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %1, i32 1)
  %3 = icmp eq i32 %2, 1
  br i1 %3, label %free, label %done

free:                                             ; preds = %nonNull
  %4 = bitcast %cl_device_id_VA %array to i8*
  tail call void @free(i8* %4)
  br label %done

done:                                             ; preds = %entry, %free, %nonNull
  ret void
}

define i32 @__cl_device_id_VA__Size(%cl_device_id_VA %array) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %null, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 2
  %2 = load i32* %1
  ret i32 %2

null:                                             ; preds = %entry
  ret i32 0
}

define i8* @__cl_device_id_VA__ConstIndex(%cl_device_id_VA %array, i32 %index) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %outOfRange, label %notNull

notNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 2
  %2 = load i32* %1
  %3 = icmp ugt i32 %2, %index
  br i1 %3, label %inRange, label %outOfRange

inRange:                                          ; preds = %notNull
  %4 = getelementptr %cl_device_id_VA %array, i32 0, i32 3, i32 %index
  %5 = load i8** %4
  ret i8* %5

outOfRange:                                       ; preds = %notNull, %entry
  %6 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%4* @8 to %String), i32 0, i32 0), i32 1)
  %7 = load i32* getelementptr (%String bitcast (%4* @8 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%4* @8 to %String), i32 0, i32 3, i32 0), i32 %7)
  ret i8* null
}

define i8** @__cl_device_id_VA__NonConstIndex(%cl_device_id_VA* nocapture %array, i32 %index) inlinehint {
entry:
  %0 = load %cl_device_id_VA* %array
  %1 = icmp eq %cl_device_id_VA %0, null
  br i1 %1, label %outOfRange, label %notNull

notNull:                                          ; preds = %entry
  %2 = getelementptr %cl_device_id_VA %0, i32 0, i32 2
  %3 = load i32* %2
  %4 = icmp ugt i32 %3, %index
  br i1 %4, label %inRange, label %outOfRange

inRange:                                          ; preds = %notNull
  %5 = getelementptr inbounds %cl_device_id_VA %0, i32 0, i32 0
  %6 = load i32* %5
  %7 = icmp ugt i32 %6, 1
  br i1 %7, label %nonUnique, label %unique

outOfRange:                                       ; preds = %notNull, %entry
  %8 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%4* @9 to %String), i32 0, i32 0), i32 1)
  %9 = load i32* getelementptr (%String bitcast (%4* @9 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%4* @9 to %String), i32 0, i32 3, i32 0), i32 %9)
  ret i8** @__cl_device_id__DefaultValue

nonUnique:                                        ; preds = %inRange
  tail call void @__cl_device_id_VA__Split(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %array)
  %.pre = load %cl_device_id_VA* %array
  br label %unique

unique:                                           ; preds = %nonUnique, %inRange
  %10 = phi %cl_device_id_VA [ %.pre, %nonUnique ], [ %0, %inRange ]
  %11 = getelementptr %cl_device_id_VA %10, i32 0, i32 3, i32 %index
  ret i8** %11
}

declare void @__cl_device_id_VA__Split(i8*, %cl_device_id_VA*)

define void @__construct_Boolean__cl_device_id_VA(i1* nocapture %booleanLValue, %cl_device_id_VA %arrayRValue) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %arrayRValue, null
  br i1 %0, label %__cl_device_id_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %arrayRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = icmp ne i32 %2, 0
  br label %__cl_device_id_VA__Size.exit

__cl_device_id_VA__Size.exit:                     ; preds = %entry, %nonNull.i
  %3 = phi i1 [ %phitmp, %nonNull.i ], [ false, %entry ]
  store i1 %3, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_device_id_VA(%String* nocapture %stringLValue, %cl_device_id_VA %arrayRValue) inlinehint {
entry:
  %arrayRValue_tempLValue = alloca %cl_device_id_VA
  store %cl_device_id_VA %arrayRValue, %cl_device_id_VA* %arrayRValue_tempLValue
  %0 = bitcast %cl_device_id_VA* %arrayRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

declare void @__cl_device_id_VA__Append(i8*, %cl_device_id_VA*, %cl_device_id_VA)

define void @__method_ASSIGN_OP_ADD__cl_device_id_VA__cl_device_id_VA(%cl_device_id_VA* nocapture %lhsLValue, %cl_device_id_VA %rhsRValue) inlinehint {
entry:
  tail call void @__cl_device_id_VA__Append(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %lhsLValue, %cl_device_id_VA %rhsRValue)
  ret void
}

define %cl_device_id_VA @__operator_ADD__cl_device_id_VA__cl_device_id_VA(%cl_device_id_VA %lhsRValue, %cl_device_id_VA %rhsRValue) inlinehint {
entry:
  %result = alloca %cl_device_id_VA
  store %cl_device_id_VA null, %cl_device_id_VA* %result
  %0 = icmp eq %cl_device_id_VA %lhsRValue, null
  br i1 %0, label %__cl_device_id_VA__Release.exit, label %__cl_device_id_VA__Retain.exit

__cl_device_id_VA__Retain.exit:                   ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %lhsRValue, i32 0, i32 0
  %2 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %__cl_device_id_VA__Release.exit

__cl_device_id_VA__Release.exit:                  ; preds = %entry, %__cl_device_id_VA__Retain.exit
  store %cl_device_id_VA %lhsRValue, %cl_device_id_VA* %result
  call void @__cl_device_id_VA__Append(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %result, %cl_device_id_VA %rhsRValue)
  %3 = load %cl_device_id_VA* %result
  ret %cl_device_id_VA %3
}

define %cl_device_id_VA* @__method_push__cl_device_id_VA__cl_device_id(%cl_device_id_VA* nocapture %selfLValue, i8* %memberRValue) nounwind inlinehint {
entry:
  %memberRValue_tempLValue = alloca i8*
  store i8* %memberRValue, i8** %memberRValue_tempLValue
  call void @__cl_device_id_VA__Push(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i8** %memberRValue_tempLValue)
  ret %cl_device_id_VA* %selfLValue
}

declare void @__cl_device_id_VA__Push(i8* nocapture, %cl_device_id_VA* nocapture, i8** nocapture) nounwind inlinehint

define i8* @__method_pop__cl_device_id_VA(%cl_device_id_VA* nocapture %selfLValue) nounwind inlinehint {
entry:
  %result = alloca i8*
  store i8* null, i8** %result
  call void @__cl_device_id_VA__Pop(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i8** %result)
  %0 = load i8** %result
  ret i8* %0
}

declare void @__cl_device_id_VA__Pop(i8* nocapture, %cl_device_id_VA* nocapture, i8** nocapture) nounwind inlinehint

define %cl_device_id_VA* @__method_resize__cl_device_id_VA__Size(%cl_device_id_VA* nocapture %selfLValue, i32 %newSizeRValue) nounwind inlinehint {
entry:
  tail call void @__cl_device_id_VA__Resize(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i32 %newSizeRValue)
  ret %cl_device_id_VA* %selfLValue
}

declare void @__cl_device_id_VA__Resize(i8*, %cl_device_id_VA*, i32) nounwind inlinehint

define %cl_device_id_VA* @__method_resize__cl_device_id_VA__Integer(%cl_device_id_VA* nocapture %selfLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  tail call void @__cl_device_id_VA__Resize(i8* bitcast (i8** @__cl_device_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i32 %integerRValue)
  ret %cl_device_id_VA* %selfLValue
}

define i32 @__method_size__cl_device_id_VA(%cl_device_id_VA %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %__cl_device_id_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  br label %__cl_device_id_VA__Size.exit

__cl_device_id_VA__Size.exit:                     ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %2, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i32 @__method_dataSize__cl_device_id_VA(%cl_device_id_VA %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %__cl_device_id_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = shl i32 %2, 2
  br label %__cl_device_id_VA__Size.exit

__cl_device_id_VA__Size.exit:                     ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %phitmp, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i8* @__method_data__cl_device_id_VA(%cl_device_id_VA %selfRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %null, label %nonNull

null:                                             ; preds = %entry
  %1 = bitcast %cl_device_id_VA %selfRValue to i8*
  ret i8* %1

nonNull:                                          ; preds = %entry
  %2 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 3, i32 0
  %3 = bitcast i8** %2 to i8*
  ret i8* %3
}

define void @__construct_Boolean__cl_event(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_event(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_event__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_event(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_event(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__cl_event_VA__Retain(%cl_device_id_VA %array) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %done

done:                                             ; preds = %entry, %nonNull
  ret void
}

define void @__cl_event_VA__Release(%cl_device_id_VA %array) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %1, i32 1)
  %3 = icmp eq i32 %2, 1
  br i1 %3, label %free, label %done

free:                                             ; preds = %nonNull
  %4 = bitcast %cl_device_id_VA %array to i8*
  tail call void @free(i8* %4)
  br label %done

done:                                             ; preds = %entry, %free, %nonNull
  ret void
}

define i32 @__cl_event_VA__Size(%cl_device_id_VA %array) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %null, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 2
  %2 = load i32* %1
  ret i32 %2

null:                                             ; preds = %entry
  ret i32 0
}

define i8* @__cl_event_VA__ConstIndex(%cl_device_id_VA %array, i32 %index) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %outOfRange, label %notNull

notNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 2
  %2 = load i32* %1
  %3 = icmp ugt i32 %2, %index
  br i1 %3, label %inRange, label %outOfRange

inRange:                                          ; preds = %notNull
  %4 = getelementptr %cl_device_id_VA %array, i32 0, i32 3, i32 %index
  %5 = load i8** %4
  ret i8* %5

outOfRange:                                       ; preds = %notNull, %entry
  %6 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%5* @10 to %String), i32 0, i32 0), i32 1)
  %7 = load i32* getelementptr (%String bitcast (%5* @10 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%5* @10 to %String), i32 0, i32 3, i32 0), i32 %7)
  ret i8* null
}

define i8** @__cl_event_VA__NonConstIndex(%cl_device_id_VA* nocapture %array, i32 %index) inlinehint {
entry:
  %0 = load %cl_device_id_VA* %array
  %1 = icmp eq %cl_device_id_VA %0, null
  br i1 %1, label %outOfRange, label %notNull

notNull:                                          ; preds = %entry
  %2 = getelementptr %cl_device_id_VA %0, i32 0, i32 2
  %3 = load i32* %2
  %4 = icmp ugt i32 %3, %index
  br i1 %4, label %inRange, label %outOfRange

inRange:                                          ; preds = %notNull
  %5 = getelementptr inbounds %cl_device_id_VA %0, i32 0, i32 0
  %6 = load i32* %5
  %7 = icmp ugt i32 %6, 1
  br i1 %7, label %nonUnique, label %unique

outOfRange:                                       ; preds = %notNull, %entry
  %8 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%5* @11 to %String), i32 0, i32 0), i32 1)
  %9 = load i32* getelementptr (%String bitcast (%5* @11 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%5* @11 to %String), i32 0, i32 3, i32 0), i32 %9)
  ret i8** @__cl_event__DefaultValue

nonUnique:                                        ; preds = %inRange
  tail call void @__cl_event_VA__Split(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %array)
  %.pre = load %cl_device_id_VA* %array
  br label %unique

unique:                                           ; preds = %nonUnique, %inRange
  %10 = phi %cl_device_id_VA [ %.pre, %nonUnique ], [ %0, %inRange ]
  %11 = getelementptr %cl_device_id_VA %10, i32 0, i32 3, i32 %index
  ret i8** %11
}

declare void @__cl_event_VA__Split(i8*, %cl_device_id_VA*)

define void @__construct_Boolean__cl_event_VA(i1* nocapture %booleanLValue, %cl_device_id_VA %arrayRValue) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %arrayRValue, null
  br i1 %0, label %__cl_event_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %arrayRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = icmp ne i32 %2, 0
  br label %__cl_event_VA__Size.exit

__cl_event_VA__Size.exit:                         ; preds = %entry, %nonNull.i
  %3 = phi i1 [ %phitmp, %nonNull.i ], [ false, %entry ]
  store i1 %3, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_event_VA(%String* nocapture %stringLValue, %cl_device_id_VA %arrayRValue) inlinehint {
entry:
  %arrayRValue_tempLValue = alloca %cl_device_id_VA
  store %cl_device_id_VA %arrayRValue, %cl_device_id_VA* %arrayRValue_tempLValue
  %0 = bitcast %cl_device_id_VA* %arrayRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_event_VA__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

declare void @__cl_event_VA__Append(i8*, %cl_device_id_VA*, %cl_device_id_VA)

define void @__method_ASSIGN_OP_ADD__cl_event_VA__cl_event_VA(%cl_device_id_VA* nocapture %lhsLValue, %cl_device_id_VA %rhsRValue) inlinehint {
entry:
  tail call void @__cl_event_VA__Append(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %lhsLValue, %cl_device_id_VA %rhsRValue)
  ret void
}

define %cl_device_id_VA @__operator_ADD__cl_event_VA__cl_event_VA(%cl_device_id_VA %lhsRValue, %cl_device_id_VA %rhsRValue) inlinehint {
entry:
  %result = alloca %cl_device_id_VA
  store %cl_device_id_VA null, %cl_device_id_VA* %result
  %0 = icmp eq %cl_device_id_VA %lhsRValue, null
  br i1 %0, label %__cl_event_VA__Release.exit, label %__cl_event_VA__Retain.exit

__cl_event_VA__Retain.exit:                       ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %lhsRValue, i32 0, i32 0
  %2 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %__cl_event_VA__Release.exit

__cl_event_VA__Release.exit:                      ; preds = %entry, %__cl_event_VA__Retain.exit
  store %cl_device_id_VA %lhsRValue, %cl_device_id_VA* %result
  call void @__cl_event_VA__Append(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %result, %cl_device_id_VA %rhsRValue)
  %3 = load %cl_device_id_VA* %result
  ret %cl_device_id_VA %3
}

define %cl_device_id_VA* @__method_push__cl_event_VA__cl_event(%cl_device_id_VA* nocapture %selfLValue, i8* %memberRValue) nounwind inlinehint {
entry:
  %memberRValue_tempLValue = alloca i8*
  store i8* %memberRValue, i8** %memberRValue_tempLValue
  call void @__cl_event_VA__Push(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i8** %memberRValue_tempLValue)
  ret %cl_device_id_VA* %selfLValue
}

declare void @__cl_event_VA__Push(i8* nocapture, %cl_device_id_VA* nocapture, i8** nocapture) nounwind inlinehint

define i8* @__method_pop__cl_event_VA(%cl_device_id_VA* nocapture %selfLValue) nounwind inlinehint {
entry:
  %result = alloca i8*
  store i8* null, i8** %result
  call void @__cl_event_VA__Pop(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i8** %result)
  %0 = load i8** %result
  ret i8* %0
}

declare void @__cl_event_VA__Pop(i8* nocapture, %cl_device_id_VA* nocapture, i8** nocapture) nounwind inlinehint

define %cl_device_id_VA* @__method_resize__cl_event_VA__Size(%cl_device_id_VA* nocapture %selfLValue, i32 %newSizeRValue) nounwind inlinehint {
entry:
  tail call void @__cl_event_VA__Resize(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i32 %newSizeRValue)
  ret %cl_device_id_VA* %selfLValue
}

declare void @__cl_event_VA__Resize(i8*, %cl_device_id_VA*, i32) nounwind inlinehint

define %cl_device_id_VA* @__method_resize__cl_event_VA__Integer(%cl_device_id_VA* nocapture %selfLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  tail call void @__cl_event_VA__Resize(i8* bitcast (i8** @__cl_event_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i32 %integerRValue)
  ret %cl_device_id_VA* %selfLValue
}

define i32 @__method_size__cl_event_VA(%cl_device_id_VA %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %__cl_event_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  br label %__cl_event_VA__Size.exit

__cl_event_VA__Size.exit:                         ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %2, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i32 @__method_dataSize__cl_event_VA(%cl_device_id_VA %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %__cl_event_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = shl i32 %2, 2
  br label %__cl_event_VA__Size.exit

__cl_event_VA__Size.exit:                         ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %phitmp, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i8* @__method_data__cl_event_VA(%cl_device_id_VA %selfRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %null, label %nonNull

null:                                             ; preds = %entry
  %1 = bitcast %cl_device_id_VA %selfRValue to i8*
  ret i8* %1

nonNull:                                          ; preds = %entry
  %2 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 3, i32 0
  %3 = bitcast i8** %2 to i8*
  ret i8* %3
}

define void @__construct_Boolean__cl_kernel(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_kernel(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_kernel__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_kernel(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_kernel(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__cl_mem(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_mem(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_mem__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_mem(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_mem(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__construct_Boolean__cl_platform_id(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_platform_id(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_platform_id__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_platform_id(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_platform_id(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define void @__cl_platform_id_VA__Retain(%cl_device_id_VA %array) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %done

done:                                             ; preds = %entry, %nonNull
  ret void
}

define void @__cl_platform_id_VA__Release(%cl_device_id_VA %array) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %done, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 0
  %2 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %1, i32 1)
  %3 = icmp eq i32 %2, 1
  br i1 %3, label %free, label %done

free:                                             ; preds = %nonNull
  %4 = bitcast %cl_device_id_VA %array to i8*
  tail call void @free(i8* %4)
  br label %done

done:                                             ; preds = %entry, %free, %nonNull
  ret void
}

define i32 @__cl_platform_id_VA__Size(%cl_device_id_VA %array) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %null, label %nonNull

nonNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 2
  %2 = load i32* %1
  ret i32 %2

null:                                             ; preds = %entry
  ret i32 0
}

define i8* @__cl_platform_id_VA__ConstIndex(%cl_device_id_VA %array, i32 %index) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %array, null
  br i1 %0, label %outOfRange, label %notNull

notNull:                                          ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %array, i32 0, i32 2
  %2 = load i32* %1
  %3 = icmp ugt i32 %2, %index
  br i1 %3, label %inRange, label %outOfRange

inRange:                                          ; preds = %notNull
  %4 = getelementptr %cl_device_id_VA %array, i32 0, i32 3, i32 %index
  %5 = load i8** %4
  ret i8* %5

outOfRange:                                       ; preds = %notNull, %entry
  %6 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%6* @12 to %String), i32 0, i32 0), i32 1)
  %7 = load i32* getelementptr (%String bitcast (%6* @12 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%6* @12 to %String), i32 0, i32 3, i32 0), i32 %7)
  ret i8* null
}

define i8** @__cl_platform_id_VA__NonConstIndex(%cl_device_id_VA* nocapture %array, i32 %index) inlinehint {
entry:
  %0 = load %cl_device_id_VA* %array
  %1 = icmp eq %cl_device_id_VA %0, null
  br i1 %1, label %outOfRange, label %notNull

notNull:                                          ; preds = %entry
  %2 = getelementptr %cl_device_id_VA %0, i32 0, i32 2
  %3 = load i32* %2
  %4 = icmp ugt i32 %3, %index
  br i1 %4, label %inRange, label %outOfRange

inRange:                                          ; preds = %notNull
  %5 = getelementptr inbounds %cl_device_id_VA %0, i32 0, i32 0
  %6 = load i32* %5
  %7 = icmp ugt i32 %6, 1
  br i1 %7, label %nonUnique, label %unique

outOfRange:                                       ; preds = %notNull, %entry
  %8 = tail call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%6* @13 to %String), i32 0, i32 0), i32 1)
  %9 = load i32* getelementptr (%String bitcast (%6* @13 to %String), i32 0, i32 2)
  tail call void @report(i8* getelementptr (%String bitcast (%6* @13 to %String), i32 0, i32 3, i32 0), i32 %9)
  ret i8** @__cl_platform_id__DefaultValue

nonUnique:                                        ; preds = %inRange
  tail call void @__cl_platform_id_VA__Split(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %array)
  %.pre = load %cl_device_id_VA* %array
  br label %unique

unique:                                           ; preds = %nonUnique, %inRange
  %10 = phi %cl_device_id_VA [ %.pre, %nonUnique ], [ %0, %inRange ]
  %11 = getelementptr %cl_device_id_VA %10, i32 0, i32 3, i32 %index
  ret i8** %11
}

declare void @__cl_platform_id_VA__Split(i8*, %cl_device_id_VA*)

define void @__construct_Boolean__cl_platform_id_VA(i1* nocapture %booleanLValue, %cl_device_id_VA %arrayRValue) nounwind inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %arrayRValue, null
  br i1 %0, label %__cl_platform_id_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %arrayRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = icmp ne i32 %2, 0
  br label %__cl_platform_id_VA__Size.exit

__cl_platform_id_VA__Size.exit:                   ; preds = %entry, %nonNull.i
  %3 = phi i1 [ %phitmp, %nonNull.i ], [ false, %entry ]
  store i1 %3, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_platform_id_VA(%String* nocapture %stringLValue, %cl_device_id_VA %arrayRValue) inlinehint {
entry:
  %arrayRValue_tempLValue = alloca %cl_device_id_VA
  store %cl_device_id_VA %arrayRValue, %cl_device_id_VA* %arrayRValue_tempLValue
  %0 = bitcast %cl_device_id_VA* %arrayRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

declare void @__cl_platform_id_VA__Append(i8*, %cl_device_id_VA*, %cl_device_id_VA)

define void @__method_ASSIGN_OP_ADD__cl_platform_id_VA__cl_platform_id_VA(%cl_device_id_VA* nocapture %lhsLValue, %cl_device_id_VA %rhsRValue) inlinehint {
entry:
  tail call void @__cl_platform_id_VA__Append(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %lhsLValue, %cl_device_id_VA %rhsRValue)
  ret void
}

define %cl_device_id_VA @__operator_ADD__cl_platform_id_VA__cl_platform_id_VA(%cl_device_id_VA %lhsRValue, %cl_device_id_VA %rhsRValue) inlinehint {
entry:
  %result = alloca %cl_device_id_VA
  store %cl_device_id_VA null, %cl_device_id_VA* %result
  %0 = icmp eq %cl_device_id_VA %lhsRValue, null
  br i1 %0, label %__cl_platform_id_VA__Release.exit, label %__cl_platform_id_VA__Retain.exit

__cl_platform_id_VA__Retain.exit:                 ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %lhsRValue, i32 0, i32 0
  %2 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* %1, i32 1)
  br label %__cl_platform_id_VA__Release.exit

__cl_platform_id_VA__Release.exit:                ; preds = %entry, %__cl_platform_id_VA__Retain.exit
  store %cl_device_id_VA %lhsRValue, %cl_device_id_VA* %result
  call void @__cl_platform_id_VA__Append(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %result, %cl_device_id_VA %rhsRValue)
  %3 = load %cl_device_id_VA* %result
  ret %cl_device_id_VA %3
}

define %cl_device_id_VA* @__method_push__cl_platform_id_VA__cl_platform_id(%cl_device_id_VA* nocapture %selfLValue, i8* %memberRValue) nounwind inlinehint {
entry:
  %memberRValue_tempLValue = alloca i8*
  store i8* %memberRValue, i8** %memberRValue_tempLValue
  call void @__cl_platform_id_VA__Push(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i8** %memberRValue_tempLValue)
  ret %cl_device_id_VA* %selfLValue
}

declare void @__cl_platform_id_VA__Push(i8* nocapture, %cl_device_id_VA* nocapture, i8** nocapture) nounwind inlinehint

define i8* @__method_pop__cl_platform_id_VA(%cl_device_id_VA* nocapture %selfLValue) nounwind inlinehint {
entry:
  %result = alloca i8*
  store i8* null, i8** %result
  call void @__cl_platform_id_VA__Pop(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i8** %result)
  %0 = load i8** %result
  ret i8* %0
}

declare void @__cl_platform_id_VA__Pop(i8* nocapture, %cl_device_id_VA* nocapture, i8** nocapture) nounwind inlinehint

define %cl_device_id_VA* @__method_resize__cl_platform_id_VA__Size(%cl_device_id_VA* nocapture %selfLValue, i32 %newSizeRValue) nounwind inlinehint {
entry:
  tail call void @__cl_platform_id_VA__Resize(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i32 %newSizeRValue)
  ret %cl_device_id_VA* %selfLValue
}

declare void @__cl_platform_id_VA__Resize(i8*, %cl_device_id_VA*, i32) nounwind inlinehint

define %cl_device_id_VA* @__method_resize__cl_platform_id_VA__Integer(%cl_device_id_VA* nocapture %selfLValue, i32 %integerRValue) nounwind inlinehint {
entry:
  tail call void @__cl_platform_id_VA__Resize(i8* bitcast (i8** @__cl_platform_id_VA__Adapter to i8*), %cl_device_id_VA* %selfLValue, i32 %integerRValue)
  ret %cl_device_id_VA* %selfLValue
}

define i32 @__method_size__cl_platform_id_VA(%cl_device_id_VA %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %__cl_platform_id_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  br label %__cl_platform_id_VA__Size.exit

__cl_platform_id_VA__Size.exit:                   ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %2, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i32 @__method_dataSize__cl_platform_id_VA(%cl_device_id_VA %selfRValue) nounwind readonly inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %__cl_platform_id_VA__Size.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %1 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 2
  %2 = load i32* %1
  %phitmp = shl i32 %2, 2
  br label %__cl_platform_id_VA__Size.exit

__cl_platform_id_VA__Size.exit:                   ; preds = %entry, %nonNull.i
  %3 = phi i32 [ %phitmp, %nonNull.i ], [ 0, %entry ]
  ret i32 %3
}

define i8* @__method_data__cl_platform_id_VA(%cl_device_id_VA %selfRValue) nounwind readnone inlinehint {
entry:
  %0 = icmp eq %cl_device_id_VA %selfRValue, null
  br i1 %0, label %null, label %nonNull

null:                                             ; preds = %entry
  %1 = bitcast %cl_device_id_VA %selfRValue to i8*
  ret i8* %1

nonNull:                                          ; preds = %entry
  %2 = getelementptr %cl_device_id_VA %selfRValue, i32 0, i32 3, i32 0
  %3 = bitcast i8** %2 to i8*
  ret i8* %3
}

define void @__construct_Boolean__cl_program(i1* nocapture %booleanLValue, i8* %opaqueRValue) nounwind inlinehint {
entry:
  %0 = icmp ne i8* %opaqueRValue, null
  store i1 %0, i1* %booleanLValue
  ret void
}

define void @__construct_String__cl_program(%String* nocapture %stringLValue, i8* %opaqueRValue) inlinehint {
entry:
  %opaqueRValue_tempLValue = alloca i8*
  store i8* %opaqueRValue, i8** %opaqueRValue_tempLValue
  %0 = bitcast i8** %opaqueRValue_tempLValue to i8*
  %1 = call %String @__String__Cast(i8* %0, i8* bitcast (i8** @__cl_program__Adapter to i8*))
  %2 = load %String* %stringLValue
  store %String %1, %String* %stringLValue
  %3 = icmp eq %String %2, null
  br i1 %3, label %__String__Release.exit, label %nonNull.i

nonNull.i:                                        ; preds = %entry
  %4 = getelementptr %String %2, i32 0, i32 0
  %5 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %4, i32 1)
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %free.i, label %__String__Release.exit

free.i:                                           ; preds = %nonNull.i
  %7 = bitcast %String %2 to i8*
  call void @free(i8* %7)
  br label %__String__Release.exit

__String__Release.exit:                           ; preds = %entry, %nonNull.i, %free.i
  ret void
}

define i32 @__method_dataSize__cl_program(i8* nocapture %selfRValue) nounwind readnone inlinehint {
entry:
  ret i32 4
}

define i8* @__method_data__cl_program(i8** nocapture %selfLValue) nounwind readnone inlinehint {
entry:
  %0 = bitcast i8** %selfLValue to i8*
  ret i8* %0
}

define i8 @computeDwell(float %x, float %y) nounwind readnone inlinehint {
entry:
  br label %loopCheckPreCond

loopCheckPreCond:                                 ; preds = %cond_done, %entry
  %0 = phi i8 [ 0, %entry ], [ %11, %cond_done ]
  %z_im.0 = phi float [ %y, %entry ], [ %10, %cond_done ]
  %z_re.0 = phi float [ %x, %entry ], [ %7, %cond_done ]
  %1 = icmp eq i8 %0, -1
  br i1 %1, label %loopEnd, label %loopBody

loopBody:                                         ; preds = %loopCheckPreCond
  %2 = fmul float %z_re.0, %z_re.0
  %3 = fmul float %z_im.0, %z_im.0
  %4 = fadd float %2, %3
  %5 = fcmp ult float %4, 4.000000e+00
  br i1 %5, label %cond_done, label %loopEnd

loopEnd:                                          ; preds = %loopBody, %loopCheckPreCond
  ret i8 %0

cond_done:                                        ; preds = %loopBody
  %6 = fsub float %2, %3
  %7 = fadd float %6, %x
  %8 = fmul float %z_re.0, 2.000000e+00
  %9 = fmul float %8, %z_im.0
  %10 = fadd float %9, %y
  %11 = add i8 %0, 1
  br label %loopCheckPreCond
}

define void @entry() inlinehint {
entry:
  %rowString = alloca %String
  br label %loopBody

loopBody:                                         ; preds = %__String__Release.exit27, %entry
  %0 = phi i32 [ 0, %entry ], [ %40, %__String__Release.exit27 ]
  %1 = sitofp i32 %0 to float
  %2 = fmul float %1, 4.000000e+00
  %3 = fdiv float %2, 4.000000e+01
  %4 = fadd float %3, -2.000000e+00
  store %String null, %String* %rowString
  br label %loopBody2

loopEnd:                                          ; preds = %__String__Release.exit27
  ret void

loopBody2:                                        ; preds = %cond_done, %loopBody
  %5 = phi i32 [ 0, %loopBody ], [ %46, %cond_done ]
  %6 = sitofp i32 %5 to float
  %7 = fmul float %6, 4.000000e+00
  %8 = fdiv float %7, 7.800000e+01
  %9 = fadd float %8, -2.000000e+00
  br label %loopCheckPreCond.i

loopCheckPreCond.i:                               ; preds = %cond_done.i, %loopBody2
  %10 = phi i8 [ 0, %loopBody2 ], [ %21, %cond_done.i ]
  %z_im.0.i = phi float [ %4, %loopBody2 ], [ %20, %cond_done.i ]
  %z_re.0.i = phi float [ %9, %loopBody2 ], [ %17, %cond_done.i ]
  %11 = icmp eq i8 %10, -1
  br i1 %11, label %computeDwell.exit, label %loopBody.i

loopBody.i:                                       ; preds = %loopCheckPreCond.i
  %12 = fmul float %z_re.0.i, %z_re.0.i
  %13 = fmul float %z_im.0.i, %z_im.0.i
  %14 = fadd float %12, %13
  %15 = fcmp ult float %14, 4.000000e+00
  br i1 %15, label %cond_done.i, label %computeDwell.exit

cond_done.i:                                      ; preds = %loopBody.i
  %16 = fsub float %12, %13
  %17 = fadd float %16, %9
  %18 = fmul float %z_re.0.i, 2.000000e+00
  %19 = fmul float %18, %z_im.0.i
  %20 = fadd float %19, %4
  %21 = add i8 %10, 1
  br label %loopCheckPreCond.i

computeDwell.exit:                                ; preds = %loopCheckPreCond.i, %loopBody.i
  %22 = zext i8 %10 to i32
  %23 = and i32 %22, 192
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %cond_false, label %cond_true

loopEnd5:                                         ; preds = %cond_done
  %25 = load %String* %rowString
  %26 = icmp eq %String %25, null
  br i1 %26, label %__String__Release.exit27, label %nonNull.i

nonNull.i:                                        ; preds = %loopEnd5
  %27 = getelementptr %String %25, i32 0, i32 0
  %28 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* %27, i32 1)
  %29 = getelementptr %String %25, i32 0, i32 3, i32 0
  %30 = getelementptr %String %25, i32 0, i32 2
  %31 = load i32* %30
  call void @report(i8* %29, i32 %31)
  %32 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %27, i32 1)
  %33 = icmp eq i32 %32, 1
  br i1 %33, label %free.i23, label %__String__Release.exit24

free.i23:                                         ; preds = %nonNull.i
  %34 = bitcast %String %25 to i8*
  call void @free(i8* %34)
  br label %__String__Release.exit24

__String__Release.exit24:                         ; preds = %nonNull.i, %free.i23
  %.pr = load %String* %rowString
  %35 = icmp eq %String %.pr, null
  br i1 %35, label %__String__Release.exit27, label %nonNull.i25

nonNull.i25:                                      ; preds = %__String__Release.exit24
  %36 = getelementptr %String %.pr, i32 0, i32 0
  %37 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %36, i32 1)
  %38 = icmp eq i32 %37, 1
  br i1 %38, label %free.i26, label %__String__Release.exit27

free.i26:                                         ; preds = %nonNull.i25
  %39 = bitcast %String %.pr to i8*
  call void @free(i8* %39)
  br label %__String__Release.exit27

__String__Release.exit27:                         ; preds = %loopEnd5, %__String__Release.exit24, %nonNull.i25, %free.i26
  %40 = add i32 %0, 1
  %exitcond29 = icmp eq i32 %40, 41
  br i1 %exitcond29, label %loopEnd, label %loopBody

cond_true:                                        ; preds = %computeDwell.exit
  %41 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%7* @14 to %String), i32 0, i32 0), i32 1)
  call void @__String__Append(%String* %rowString, %String bitcast (%7* @14 to %String))
  %42 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* getelementptr (%String bitcast (%7* @14 to %String), i32 0, i32 0), i32 1)
  %43 = icmp eq i32 %42, 1
  br i1 %43, label %free.i21, label %cond_done

free.i21:                                         ; preds = %cond_true
  call void @free(i8* bitcast (%7* @14 to i8*))
  br label %cond_done

cond_false:                                       ; preds = %computeDwell.exit
  %44 = and i32 %22, 48
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %cond_false8, label %cond_true7

cond_done:                                        ; preds = %free.i, %cond_false13, %free.i17, %cond_true12, %free.i19, %cond_true7, %free.i21, %cond_true
  %46 = add i32 %5, 1
  %exitcond = icmp eq i32 %46, 79
  br i1 %exitcond, label %loopEnd5, label %loopBody2

cond_true7:                                       ; preds = %cond_false
  %47 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%7* @15 to %String), i32 0, i32 0), i32 1)
  call void @__String__Append(%String* %rowString, %String bitcast (%7* @15 to %String))
  %48 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* getelementptr (%String bitcast (%7* @15 to %String), i32 0, i32 0), i32 1)
  %49 = icmp eq i32 %48, 1
  br i1 %49, label %free.i19, label %cond_done

free.i19:                                         ; preds = %cond_true7
  call void @free(i8* bitcast (%7* @15 to i8*))
  br label %cond_done

cond_false8:                                      ; preds = %cond_false
  %50 = and i32 %22, 12
  %51 = icmp eq i32 %50, 0
  br i1 %51, label %cond_false13, label %cond_true12

cond_true12:                                      ; preds = %cond_false8
  %52 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%7* @16 to %String), i32 0, i32 0), i32 1)
  call void @__String__Append(%String* %rowString, %String bitcast (%7* @16 to %String))
  %53 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* getelementptr (%String bitcast (%7* @16 to %String), i32 0, i32 0), i32 1)
  %54 = icmp eq i32 %53, 1
  br i1 %54, label %free.i17, label %cond_done

free.i17:                                         ; preds = %cond_true12
  call void @free(i8* bitcast (%7* @16 to i8*))
  br label %cond_done

cond_false13:                                     ; preds = %cond_false8
  %55 = call i32 @llvm.atomic.load.add.i32.p0i32(i32* getelementptr (%String bitcast (%7* @17 to %String), i32 0, i32 0), i32 1)
  call void @__String__Append(%String* %rowString, %String bitcast (%7* @17 to %String))
  %56 = call i32 @llvm.atomic.load.sub.i32.p0i32(i32* getelementptr (%String bitcast (%7* @17 to %String), i32 0, i32 0), i32 1)
  %57 = icmp eq i32 %56, 1
  br i1 %57, label %free.i, label %cond_done

free.i:                                           ; preds = %cond_false13
  call void @free(i8* bitcast (%7* @17 to i8*))
  br label %cond_done
}
