<?xml version='1.0' encoding='UTF-8'?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:db="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Fabric Engine SceneGraph Documentation</title>
    <copyright>
      <year>2012</year>
      <holder>Fabric Engine Inc.</holder>
    </copyright>
    <author>
      <personname>
        <firstname>Helge</firstname>
        <surname>Mathee</surname>
      </personname>
      <affiliation>
        <orgname>Fabric Engine Inc.</orgname>
        <address>
          <email>helge.mathee@fabric-engine.com</email>
        </address>
      </affiliation>
    </author>
  </info>
  <section>
    <title>Introduction</title>
    <section>
      <title>What's Fabric Engine's SceneGraph?</title>
      <para>The <emphasis role="bold">SceneGraph</emphasis> is a wrapper for its counterpart, the
        Fabric Engine Core. Fabric Engine's core is a very low level system, providing the core
        objects such as a <emphasis role="bold">Dependency Graph Node</emphasis>, <emphasis
          role="bold">Operators</emphasis> and other elements. The <emphasis role="bold"
          >SceneGraph</emphasis> however is an abstraction layer for the core. It provides <emphasis
          role="italic">presets</emphasis> for Dependency Graph Node setups, called the
        SceneGraphNodes. The SceneGraph is purely implemented in JavaScript, and therefore can be
        customized easily for any specialized purpose.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_introduction_01.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The SceneGraph is a factory which is used to create SceneGraphNodes. Each type of
        SceneGraphNode is registered with the SceneGraph on load. The factory function is
        responsible for constructing the underlying dependency graph, and returning an public
        interface. All data associated with the scene graph node is contained in the closure defined
        by the factory function. </para>
      <para>A good understanding of closures and how they work in JavaScript is essential for
        understanding the Fabric SceneGraph.</para>
      <para>The SceneGraph is provided as a series of JavaScript files which implement factory
        functions for a certain usage field, for example the file <emphasis role="italic"
          >Images.js</emphasis> contains several factory functions implementing 2D images, 3D images
        and video SceneGraphNodes.</para>
      <para>SceneGraphNodes encapsulate the core objects necessary to provide a certain
        functionality. The VideoNode, for example, contains the Dependency Graph Nodes to store all
        of the video related data, as well as all of the Operators to read and manipulate the video
        stream. Moreover it provides JavaScript functions to access and manipulate the video. </para>
      <para>SceneGraphNodes that don't contain any Dependency Graph Node, and are used mainly to
        provide utility functionality, are called <emphasis role="bold">Managers</emphasis>. One
        example of a manager is the UndoManager.</para>
      <para>The SceneGraph furthermore provides graphical utilities, such as the <emphasis
          role="bold">Debugger</emphasis>, which allows to inspect the constructed core Dependency
        Graph, and other tools, for example the <emphasis role="bold">Curve Editor</emphasis>, which
        allows to inspect and edit FCurve animation.</para>
    </section>
    <section>
      <title>Abstraction of the Dependency Graph</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_introduction_02.png" width="75%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The goal of the SceneGraph layer is to present an interface to developers focused on
        SceneGraph construction. The interfaces exposed follow common SceneGraph conventions. </para>
      <para>SceneGraphs can be setup in a few lines of code, and provide a rich array of features,
        from shader management and rendering, to manipulation and animation.</para>
      <para>The SceneGraph is written entirely in JavaScript, and it abstracts the notion of the
        dependency graph away from the user. The JavaScript code assembles a lower level dependency
        graph. </para>
    </section>
    <section>
      <title>Scene Object and SceneGraphNode Construction</title>
      <para>The <emphasis role="bold">scene</emphasis> object is the accessor for the SceneGraph
        factory, and is used to construct any SceneGraphNode.</para>
      <para>
        <programlisting>var scene = FABRIC.SceneGraph.createScene();</programlisting>
      </para>
      <para>The first SceneGraph object to be constructed is usually the scene object. The scene
        object creates a Fabric dependency graph context, a dependency graph node for containing
        globals, and some event handlers that are used in rendering. It returns an interface for
        constructing SceneGrapNodes. </para>
      <para>All SceneGraphNodes implemented in the SceneGraph are registered by providing their type
        as well as a constructor function. A node of a registered type can be constructed by using
        JavaScript like this:</para>
      <para>
        <programlisting>var sgNode = scene.constructNode('Image2D', { name: 'myImageNode' } );</programlisting>
      </para>
      <para>The options supported by each SceneGraphNode can be found in the following chapters,
        respectively in the <emphasis role="bold">SceneGraphNode Reference</emphasis> of this
        document. </para>
    </section>
    <section>
      <title>Public and Private Interfaces</title>
      <para>SceneGraphNodes provide a private as well as a public interface. Outside of constructor
        functions it's only possible to access the public interface, while inside of constructor
        functions it's possible to access the private interface. This allows to include helper
        functions in the each node, such as setter functions for private members for example, that
        are only accessible in constructor functions of other nodes. Since the options used for the
        construction of a node can contain references to a public interface, you can retrieve the
        private interface by using this call:</para>
      <programlisting>var privateInterface = scene.getPrivateInterface(publicInterface);</programlisting>
      <para>To access the public interface from a private one, you simply need to access the
          <emphasis role="italic">.pub</emphasis> member of the private interface.<emphasis
          role="bold"> </emphasis>Managers can also access private interfaces, allowing them to
        perform changes to the private data, for example.</para>
      <programlisting language="JavaScript">var sgNode = {
  pub: {
    publicMethod: function () {}
  },
  privateMethod: function () {}
};</programlisting>
    </section>
    <section>
      <title>Custom SceneGraphNodes and Inheritance</title>
      <para>Applications can register their own, custom SceneGraphNodes. This can be useful and
        necessary when extending an existing node, for example, or providing a completely new one.
        Inside the constructor function of the custom node all other nodes can be accessed through
        their private interfaces, allowing to modify and access the inner workings of the
        SceneGraph. Extending the private or the public interface allows to inherit features of
        another SceneGraphNode. It is also possible to override an existing function on each
        interface by simply setting it to different function inside the custom node's constructor.
        For further details refer to the tutorials sections of this document.</para>
    </section>
    <section>
      <title>The SceneGraph Debugger</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/sg_debugger_01.png" width="100%"/>
        </imageobject>
      </mediaobject>
      <para>The debugger is a useful tool to inspect the dependency graph contructed by the
        SceneGraph. Especially when building custom SceneGraphNodes this can be very helpful. The
        debugger is described in more detail in the section on the Drawing Pipeline Guide in this
        document. You can open the debugger by using executing this code in JavaScript:</para>
      <programlisting language="JavaScript">FABRIC.displayDebugger();</programlisting>
    </section>
  </section>
  <section role="">
    <title>SceneGraph Type System</title>
    <para>Fabric Engine can work with any type of data. To define the structure of data, you need to
      introduce <emphasis role="bold">Types</emphasis>. Types are very similar to structs in C++.
      Core types, such as <emphasis role="bold">Integer</emphasis>, <emphasis role="bold"
        >Boolean</emphasis> or <emphasis role="bold">String</emphasis> are defined by the core. More
      complex types, such as the <emphasis role="bold">Vec3</emphasis>, for example, are defined by
      the SceneGraph.</para>
    <section>
      <title>Querying types</title>
      <para>You can access all of the currently registered types, by calling on the <emphasis
          role="bold">RegisteredTypesManager</emphasis>. The manager is only accessible in the scope
        of a SceneGraphNode factory function, but you can access a dictionary of all current types
        by accessing the <emphasis role="bold">RT</emphasis> object:</para>
      <programlisting language="JavaScript">console.log(FABRIC.RT);</programlisting>
      <para>Types are typically implemented in separate JavaScript files. The ones provided by the
        SceneGraph can be found in the RT directory. The SceneGraph uses a <emphasis role="bold"
          >require</emphasis> framework which ensures that all required scripts are automatically
        included into the application. You can find more details about this in the tutorials section
        of this document, covering the creation of a custom SceneGraphNode.</para>
    </section>
    <section>
      <title>JavaScript and KL</title>
      <para>Types can provide extra functionality both in JavaScript as well as Fabric Engine's
        kernel language (<emphasis role="bold">KL</emphasis>). The type below implements an
          <emphasis role="bold">Address</emphasis>, and implements both a JavaScript file as well as
        a KL file providing the additional functions, called the <emphasis role="bold"
          >bindings</emphasis>. The content of the JavaScript file looks like this: (the first array
        parameter is the list of requirements. this could include other types, for example.)</para>
      <programlisting language="JavaScript">FABRIC.define([], function() {

  // Constructor:
  FABRIC.RT.Address = function(options) {
    if(!options) options = {};
    this.street = options.street != undefined ? options.street : '';
    this.number = options.number != undefined ? options.number : 1;
    this.city = options.city != undefined ? options.city : '';
    this.zip = options.zip != undefined ? options.zip : 1000;
    this.country = options.country != undefined ? options.country : '';
  };
  
  // Prototype, providing additional methods
  FABRIC.RT.Address.prototype = {
    getPrintable: function() {
      return this.street + ' ' + this.number + ' in ' + this.zip + ' ' + this.city + ', ' + this.country;
    }
  };
  
  // Append this type to be loaded once the Fabric context exists
  FABRIC.appendOnCreateContextCallback(function(context) {
    context.RegisteredTypesManager.registerType('Address', {
      members: {
        street: 'String', number: 'Integer', city: 'String', zip: 'Integer', country: 'String'
      },
      constructor: FABRIC.RT.Address,
      klBindings: {
        filename: 'Address.kl',
        sourceCode: FABRIC.loadResourceURL('RT/Address.kl')
      }
    });
  });

  return FABRIC.RT.Address;
});</programlisting>
      <para>The KL file mentioned in the appendOnCreateContextCallback above, <emphasis role="bold"
          >RT/Address.kl</emphasis> could look like this:</para>
      <programlisting language="JavaScript">function String Address.getPrintable() {
  return this.street + ' ' + this.number + ' in ' + this.zip + ' ' + this.city + ', ' + this.country;
}</programlisting>
      <para>This will make the <emphasis role="bold">getPrintable</emphasis> method available both
        in JavaScript as well as in KL. As you can see, you can specify any type of data. You can of
        course include custom types as members of other custom types, and therefore build very
        complex structures, which then can be used for computation inside the dependency graph or
        MapReduce.</para>
    </section>
  </section>
  <section>
    <title>Kinematics Guide</title>
    <section>
      <title>Basic Transform</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_kinematics_01.png" width="45%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The SceneGraph's basic transform can represent a global or a hierarchical transform. It
        can be contructed like this:</para>
      <programlisting language="JavaScript">var globalTransform = scene.constructNode('Transform', {
  hierarchical: false
});
var hierarchicalTransform = scene.constructNode('Transform', {
  hierarchical: true,
  parentTransformNode: globalTransform
});</programlisting>
      <para>When contructed in global mode (hierarchical: false), the transform simply uses a global
        matrix. When contructed in hierarchical mode, the construction options need to contain a
        parent transform. An operator will be attached to the transform node, which computes the
        global matrix based on the parent as well as a local matrix. This way hierarchies of
        transforms can be constructed.</para>
      <para>When creating the transform node, you can specify the global resp. the local matrix by a
          <emphasis role="bold">FABRIC.RT.Xfo</emphasis>, like this:</para>
      <programlisting language="JavaScript">var globalTransform = scene.constructNode('Transform', {
  hierarchical: false,
  globalXfo: new FABRIC.RT.Xfo({
    tr: new FABRIC.RT.Vec3(1.0, 2.0, 3.0)
  })
});</programlisting>
    </section>
    <section>
      <title>Aimed Transform</title>
      <para>For the typical <emphasis role="italic">lookat</emphasis> behaviour of a transform, for
        example used for a camera with an lookat position, or a spot light with a target position,
        the SceneGraph provides a specialized transform node called the <emphasis role="bold"
          >AimTransform</emphasis>. It adds an additional option to the factory function, which
        allows you to specify the target position.</para>
      <programlisting language="JavaScript">var aimTransform = scene.constructNode('AimTransform', {
  globalXfo: new FABRIC.RT.Xfo({
      tr: new FABRIC.RT.Vec3(1.0, 2.0, 3.0)
  }),
  target: new FABRIC.RT.Vec3(10.0, 0.0, 0.0)
});</programlisting>
      <para>The upvector direction used for the AimTransform is always the positive Y axis.</para>
    </section>
  </section>
  <section>
    <title>Animation Guide</title>
    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/sg_animation_01.png" width="60%"/>
        </imageobject>
      </inlinemediaobject></para>
    <para>The animation pipeline in Fabric Engine's SceneGraph is heavily inspired by the animation
      systems commonly found in game engines. The SceneGraphNodes in the animation pipeline
      are:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">AnimationController</emphasis></para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">TrackAnimationContainer</emphasis></para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">CharacterAnimationContainer</emphasis></para>
      </listitem>
    </itemizedlist>
    <para>The actual evaluation of the animation is done in KL operators on the target nodes. In the
      image above the animation is driving a transform node, but any node can be driven by animation
      in Fabric Engine's SceneGraph.</para>
    <section>
      <title>The Animation Controller node</title>
      <para>An Animation Controller is responsible for computing a time value from given inputs.
        This allows to simulate the time in a controller, loop or ping-pong the time or do any kind
        of manipulation on the time inside the controller. A single controller can be used by many
        evaluators. The default Animation Controller node is bound to the globals SceneGraph node
        storing the global scene time.</para>
      <programlisting language="JavaScript">var controller = scene.constructNode('AnimationController', {
  timeRange: new FABRIC.RT.Vec2(0.0, 10.0), // ten seconds
  outOfRange: 1 // looping
});</programlisting>
    </section>
    <section>
      <title>The TrackAnimationContainer</title>
      <para>Both the <emphasis role="bold">TrackAnimationContainer</emphasis> as well as the
          <emphasis role="bold">CharacterAnimationContainer</emphasis> inherit from the <emphasis
          role="bold">AnimationContainer</emphasis>. The AnimationContainer SceneGraph node
        represents a container for any kind of animation. The TrackAnimationContainer uses a sliced
        dependency graph node to store many animation tracks in a single node. All tracks on the
        TrackAnimationContainer have to contain the same type of keys, which is why you can't
        construct a TrackAnimationContainer as is, you need to instantiate inherited nodes of it,
        such as the <emphasis role="bold">LinearTrackAnimationContainer</emphasis> containing linear
        keys or <emphasis role="bold">BezierTrackAnimationContainer</emphasis> containing bezier
        keys.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_animation_02.png" width="30%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The TrackAnimationContainer represents a single animation using multiple tracks. The
        benefit of the TrackAnimationContainer is that tracks are stores in slices, and processing
        on the tracks can happen in a multi-threaded fashion.</para>
      <programlisting language="JavaScript">var linearkey = function(time, value){ return new FABRIC.RT.LinearKeyframe(time, value); };

var trackContainer = scene.constructNode('LinearTrackAnimationContainer', {});

trackContainer.addTrack(new FABRIC.RT.LinearKeyframeTrack('tr.x', FABRIC.RT.rgb(1, 0, 0), [
  linearkey(0, 0), linearkey(50, 0), linearkey(75, 50), linearkey(100, 0)
]));
trackContainer.addTrack(new FABRIC.RT.LinearKeyframeTrack('tr.y', FABRIC.RT.rgb(0, 1, 0), [
  linearkey(0, 0), linearkey(50, 10), linearkey(75, 00), linearkey(100, 0)
]));
trackContainer.addTrack(new FABRIC.RT.LinearKeyframeTrack('tr.z', FABRIC.RT.rgb(0, 0, 1), [
  linearkey(0, 0), linearkey(50, 30), linearkey(75, 00), linearkey(100, 30)
]));</programlisting>
      <para>The code above create a small helper function for creating a linear key frame, then the
        track animation container is created. Once the container exists tracks can be pushed to it,
        providing the name of the track, a color for the UI as well as an array of keys for the
        track.</para>
    </section>
    <section>
      <title>The CharacterAnimationContainer</title>
      <para>The <emphasis role="bold">CharacterAnimationContainer</emphasis> on the other hand is
        quite different from the TrackAnimationContainer. It stores a complete animation containing
        several tracks per slice, allowing to store a large number of complete animations on a
        single node. This container can be understood as a library of animations. Each animation is
        stored as a <emphasis role="bold">TrackSet</emphasis>, which is essentially an array of
        tracks as well as a name for the TrackSet.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_animation_03.png" width="70%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The CharacterAnimationContainer is used for the character pipeline, and will be
        discussed in more detail in the characters related section of this document. Essentially
        though, this is how you create a CharacterAnimationContainer:</para>
      <programlisting language="JavaScript">var linearkey = function(time, value){ return new FABRIC.RT.LinearKeyframe(time, value); };

var characterContainer = scene.constructNode('LinearCharacterAnimationContainer', {});

var walking = characterContainer.newTrackSet('walking');
walking.tracks.push(new FABRIC.RT.LinearKeyframeTrack('tr.x', FABRIC.RT.rgb(1, 0, 0), [
  linearkey(0, 0), linearkey(50, 0), linearkey(75, 50), linearkey(100, 0)
]));
walking.tracks.push(new FABRIC.RT.LinearKeyframeTrack('tr.y', FABRIC.RT.rgb(0, 1, 0), [
  linearkey(0, 0), linearkey(50, 10), linearkey(75, 00), linearkey(100, 0)
]));
walking.tracks.push(new FABRIC.RT.LinearKeyframeTrack('tr.z', FABRIC.RT.rgb(0, 0, 1), [
  linearkey(0, 0), linearkey(50, 30), linearkey(75, 00), linearkey(100, 30)
]));

characterContainer.addTrackSet(walking, [0,1,2]);</programlisting>
    </section>
    <section>
      <title>Binding animation to target nodes</title>
      <para>To use the animation on a target node, such as a transform node, for example, you can
        call the <emphasis role="bold">bindNodeMembersToTracks</emphasis> method of the animation
        container. You need to specify the target binding which includes the name of the member on
        the target node as well as the tracks that need to be bound to it. This you can drive
        complex types, as as a <emphasis role="bold">Vec3</emphasis> for example, you can bind
        multiple tracks to the same member. In the case of a Vec3 the first track will go to the x
        component, the second track to the y component and so on.</para>
      <programlisting language="JavaScript">trackContainer.bindNodeMembersToTracks(transform, {
  'globalXfo.tr': [0, 1, 2] // representing the tracks tr.x, tr.y and tr.z
}, controller);</programlisting>
      <para>Binding the animation on the target node will create an operator on the target's
        dependency graph node which evaluates the animation provided in the animation container and
        writes to the target node's member data. The operator also binds in the animation controller
        which was used during the construction of the animation container. If you don't provide a
        controller to the bindNodeMembersToTracks method the generated operator will simply bind to
        the global time. So in the case discussed in the code snippets in the animation guide, the
        resulting graph will look like this:</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_animation_04.png" width="80%"/>
          </imageobject>
        </inlinemediaobject></para>
    </section>
  </section>
  <section>
    <title>Geometry Guide</title>
    <para>The geometry hierarchy in Fabric Engine's SceneGraph follows a classical inheritance
      model. Each node in the hierarchy adds functionality the the constructed SceneGraph node.
      Geometry can be created in several ways:</para>
    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/sg_geometry_01.png" width="75%"/>
        </imageobject>
      </inlinemediaobject></para>
    <para>1. A base geometry type can be constructed, and its geometry data can be populated from
      JavaScript:</para>
    <programlisting language="JavaScript">var geometryNode = scene.pub.constructNode('Triangles');
geometryNode.loadGeometryData({
  positions: [FABRIC.RT.vec3(0, 0, 0), FABRIC.RT.vec3(0, 0, 1.0), FABRIC.RT.vec3(1.0, 0, 0)], 
  indices: [0, 1, 2]
}); </programlisting>
    <para>2. Geometry can be constructed by loading an external resource file, such as an OBJ file,
      for example:</para>
    <programlisting language="JavaScript">scene.importAssetFile('Models/cow.obj',{ splitMaterials: true } );</programlisting>
    <para>3. A primitive can be constructed. The primitive constructor assigns geometry generation
      operators which create all of the vertices and other data such as normals based on options on
      the primitive.</para>
    <programlisting language="JavaScript">var primitiveNode = scene.constructNode('Circle', { radius: 7 });</programlisting>
    <section>
      <title>Anatomy of a Geometry Node</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_geometry_02.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>A geometry SceneGraphNode contains several dependency graph nodes. Fabric Engine's
        slicing scheme is used to represent the data, and to allow high performance operations such
        as deformation on the geometry using multi-threading.</para>
      <para>The <emphasis role="bold">Uniforms</emphasis> node stores single values that are
        associated with the geometry, but don't vary per component. Primitives assign uniform values
        that are often exposed from the scene graph node as modifiable parameters. Triangles and
        Lines also store an array of Integers on the Uniforms node called <emphasis role="bold"
          >indexList</emphasis> which defines the connectivity of points for lines and
        triangles.</para>
      <para>The <emphasis role="bold">Attributes</emphasis> node stores all the ‘per-component’
        information. Attributes can easily be added and removed from geometry by simply adding and
        removing members from this node. The Attributes node is sliced, so the number of slices
        matches the number of vertices, for example.</para>
      <para>The <emphasis role="bold">BoundingBox</emphasis> node is generated using the attributes,
        and is used to accelerate interaction with the geometry such as raycasting.</para>
    </section>
    <section>
      <title>Geometry Generation</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_geometry_03.png" width="40%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Note: this are will be re-structured slightly once we have support for node
        nesting.</para>
      <para>The purpose of a generator operator is to generate the vertex information that is stored
        in the attributes node, and the indexList (for Triangles and Lines), which is stored in the
        ‘Uniforms’ node. First we calculate the number of vertices in the <emphasis role="bold"
          >setCount</emphasis> operator, and then populate the attributes node in the second
        operator. The second operator also writes the indexList which is stored on the Uniforms
        node.</para>
    </section>
    <section>
      <title>Geometry Services</title>
      <para>A key service that the the Geometry node provides is integration with the rendering
        pipeline. The design of Fabric Engine's SceneGraph is based heavily on OpenGL shading
        language GLSL, and all rendering in the OpenGL viewport is performed via shaders. </para>
      <para>The geometry node constructs an event handler and binds operators to it for loading all
        the various vertex attributes into the GPU and storing the buffer ids. This means that you
        can add a new vertex attributes to a geometry, then use that data in a shader and the
        geometry node will take care of loading the data so it is ready for the shader. This is
        discussed in more detail in the <emphasis role="bold">Drawing Pipeling Guide</emphasis>
        section of this document.</para>
    </section>
    <section>
      <title>Geometry Data Copies</title>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_geometry_04.png" width="60%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>Geometry data copies provide a way to split the definition of a rendered geometry into
        multiple sections. A Geometry data copy is used to extend a base geometry, usually by adding
        deformation operators. The base geometry represents the original undeformed geometry, and
        the data copy is used to apply changes. The Geometry data copy contains only members
        required for the modification. During rendering, uniforms and attributes are loaded from the
        base geometry and the data copy.</para>
      <para>Since the Attributes node is sliced, deformation can be performed using
        multi-threading.</para>
      <programlisting language="JavaScript">var geometryCopyNode = scene.constructNode('GeometryDataCopy', {baseGeometryNode: geometryNode} );
geometryCopyNode.addVertexAttributeValue('positions', 'Vec3', { genVBO:true, dynamic:true } );</programlisting>
      <para>Note: The <emphasis role="italic">PerPointDeformation.html</emphasis> sample application
        contains an example of this.</para>
    </section>
  </section>
  <section>
    <title>Parsers Guide</title>
    <para>Fabric Engine's SceneGraph comes with several parsers for importing external resource
      files. Since the loading of external data happens asynchronously, you will need to provide
      callback functions to the parsers, which will executed once the content is loaded, parsed and
      ready for use. Parsers are automatically invoked and chosen based on the file extension of the
      resource to load.</para>
    <section>
      <title>The OBJ Parser</title>
      <para>The OBJ file format can store polygonal meshes with UV coordinates as well as basic
        material settings. You can use the OBJ parser like this:</para>
      <programlisting language="JavaScript">scene.importAssetFile('Models/cow.obj', {splitMaterials: false}, function(assetNodes) {
  for(var name in assetNodes) {
    console.log(assetNodes[name]);
  }
});</programlisting>
      <para>The last argument to the <emphasis role="bold">importAssetFile</emphasis> method is the
        function to execute once the parsed result is ready for consumption. The OBJ parser returns
        a dictionary of triangle geometry nodes representing all of the geometries which are part of
        the OBJ file. If the <emphasis role="bold">splitMaterials</emphasis> option is set to true,
        the polygon material assignments of the OBJ file will further split the meshes, to enable
        the SceneGraph's drawing pipeline to render them with separate shaders.</para>
      <para>Note: The <emphasis role="italic">ModelViewer.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains an example of the OBJ parser in
        use.</para>
    </section>
    <section>
      <title>The Collada Parser</title>
      <para>Collada's DAE file format can store complex types of data, including polygonal meshes,
        transform hierarchies, point clouds as well as other complex 3D data structures. The
        SceneGraph's collada parser currently supports:<itemizedlist>
          <listitem>
            <para>Polygonal Meshes including UV coordinates and skinning weights, imported as
              Triangles nodes</para>
          </listitem>
          <listitem>
            <para>Character Hierarchies used for skinning, imported as CharacterRig nodes</para>
          </listitem>
          <listitem>
            <para>FCurve animation on hierarchies, imported as CharacterAnimationContainer
              nodes</para>
          </listitem>
          <listitem>
            <para>Cameras including focal length and aperture settings, imported as Camera
              nodes</para>
          </listitem>
        </itemizedlist></para>
      <para>The Collada parser can be deployed like this:</para>
      <programlisting language="JavaScript">scene.importAssetFile('Models/character.dae', {
    constructRigFromHierarchy: true
}, function(assetNodes) {
  for(var name in assetNodes) {
    console.log(assetNodes[name]);
  }
});</programlisting>
      <para>The last argument of the parser's invocation is a function to be called once the collada
        data is parsed and ready for consumption. In the example above we simply log the data to the
        console. For further details on the character related nodes please see the <emphasis
          role="bold">Character Guide</emphasis> section of this document.</para>
      <para>Note: The <emphasis role="italic">CharacterSkeleton.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains an example of the Collada parser in
        use.</para>
    </section>
    <section>
      <title>The Alembic Parser</title>
      <para>Alembic ABC file format can store several kinds of data. The SceneGraph's Alembic
        intergration currently supports:<itemizedlist>
          <listitem>
            <para>Polygonal Meshes including UV coordinates and normals, imported as Triangle
              nodes</para>
          </listitem>
          <listitem>
            <para>Curve lists including width and color values, imported as Lines nodes</para>
          </listitem>
          <listitem>
            <para>Cameras with proper focal length and aperture settings, imported as Camera
              nodes</para>
          </listitem>
          <listitem>
            <para>Point clouds including full transform support, color values, imported as Points
              nodes</para>
          </listitem>
        </itemizedlist></para>
      <para>Since Alembic stores animation as discrete samples the parser doesn't load all of the
        data to memory, but rather constructs operators which re-evaluate based on time changes.
        This way animation can be loaded into Fabric Engine and synchronized with the SceneGraph's
        global time or a different AnimationController.</para>
      <para><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/sg_parsers_01.png" width="80%"/>
          </imageobject>
        </inlinemediaobject></para>
      <para>The Alembic resource node holds what is called a <emphasis role="bold"
          >AlembicHandle</emphasis> to the original resource file, which is forwarded through the
        dependency graph and used by all of the ABC operators to pull the relevant data out of the
        Alembic file. Per se there is no parsing happening in JavaScript, so once the resource is
        loaded, the <emphasis role="bold">loadSuccess</emphasis> event fires. The sample code below
        shows how to load data from an Alembic resource. For more details on event handling please
        refer to the <emphasis role="bold">Event Guide</emphasis> section of this document.</para>
      <programlisting language="JavaScript">var alembicLoadNode = scene.constructNode('AlembicLoadNode', {
  url: 'Models/cow.abc'
});
alembicLoadNode.addEventListener('loadSuccess', function(){
  var assetNodes = alembicLoadNode.getParsedNodes(); 
  for(var name in assetNodes) {
    console.log(assetNodes[name]);
  }
});</programlisting>
      <para>Note: The <emphasis role="italic">Alembic/Primitives.html<emphasis role="bold"
          > </emphasis></emphasis>sample application contains an example of the Alembic parser in
        use.</para>
    </section>
  </section>
  <section>
    <title>Characters Guide</title>
    <para>This is do be done for Phil!</para>
  </section>
  <section>
    <title>Images and Video Guide</title>
    <para/>
  </section>
</article>
